Status: not-applied
Origin: vendor
Forwarded: no

---
Index: b/glide3x/configure.in
===================================================================
--- a/glide3x/configure.in
+++ b/glide3x/configure.in
@@ -174,7 +174,17 @@ GLIDE_SANITY_ALL=false
 GLIDE_SANITY_SIZE=false
 FX_DLL_BUILD=false
 FX_GLIDE_HW_CULL=false
+# Here we define whether we use C versions of cpu detection and triangle setup
 FX_GLIDE_CTRISETUP=false
+FX_GLIDE_C_CPU_DETECT=false
+# Override based on architecture
+if test "$FX_GLIDE_BUILD_ARCHITECTURE" = "alpha"; then
+FX_GLIDE_CTRISETUP=true
+FX_GLIDE_C_CPU_DETECT=true
+fi
+if test "$FX_GLIDE_BUILD_ARCHITECTURE" = "ia64"; then
+FX_GLIDE_CTRISETUP=true
+fi
 # Next, we read some configuration options
 # statically.  This is to avoid creating a bunch of
 # not-terribly-useful --enable options.
@@ -212,6 +222,8 @@ AM_CONDITIONAL(FX_GLIDE_HW_CULL,dnl
                test x$FX_GLIDE_HW_CULL = xtrue)
 AM_CONDITIONAL(FX_GLIDE_CTRISETUP,dnl
                test x$FX_GLIDE_CTRISETUP = xtrue)
+AM_CONDITIONAL(FX_GLIDE_C_CPU_DETECT,dnl
+               test x$FX_GLIDE_C_CPU_DETECT = xtrue)
 AM_CONDITIONAL(FX_GLIDE_PACKET_FIFO,dnl
                test x$FX_GLIDE_PACKET_FIFO = xtrue)
 AM_CONDITIONAL(FX_GLIDE_VERTEX_TABLE,dnl
Index: b/glide3x/h3/glide3/src/cpu_alpha.c
===================================================================
--- /dev/null
+++ b/glide3x/h3/glide3/src/cpu_alpha.c
@@ -0,0 +1,21 @@
+#ifdef __alpha__
+
+#include <stdio.h>
+#include <string.h>
+
+#include <3dfx.h>
+#include <glidesys.h>
+
+#define FX_DLL_DEFINITION
+#include <fxdll.h>
+#include <glide.h>
+#include "fxglide.h"
+
+#define	NOT_PENTIUM	4 /* see cpudetect.S */
+
+extern FxI32 GR_CDECL
+_cpu_detect_asm(void)
+{
+    return(NOT_PENTIUM);
+}
+#endif
Index: b/glide3x/h3/glide3/src/cpudtect.S
===================================================================
--- a/glide3x/h3/glide3/src/cpudtect.S
+++ b/glide3x/h3/glide3/src/cpudtect.S
@@ -48,7 +48,19 @@
 /*  2     3/04/97 9:10p Dow */
 /*  Neutered mutiplatform multiheaded monster. */
 
+#ifdef __ia64__
 
+	.align 32
+	.global _cpu_detect_asm
+	.proc _cpu_detect_asm
+
+_cpu_detect_asm:
+	mov ret0=0
+	br.ret.sptk.few b0
+
+	.end _cpu_detect_asm
+
+#else /* !__ia64__ */
 
 .file "cpudtect.asm"
 
@@ -324,3 +336,4 @@ double_precision_asm:
 .size double_precision_asm,.L_END_double_precision_asm-double_precision_asm
 
 .end
+#endif
Index: b/glide3x/h3/glide3/src/diget.c
===================================================================
--- a/glide3x/h3/glide3/src/diget.c
+++ b/glide3x/h3/glide3/src/diget.c
@@ -615,10 +615,10 @@ GR_DIENTRY(grGet, FxU32, (FxU32 pname, F
     break;
 
   case GR_SURFACE_TEXTURE:
-    if (plength == 4) {
+    if (plength == sizeof(long)) {
       GR_DCL_GC;
 
-      *params = (FxU32) &gc->tBuffer;
+      *params = (AnyPtr) &gc->tBuffer;
       retVal = plength;
     }
     break;
Index: b/glide3x/h3/glide3/src/disst.c
===================================================================
--- a/glide3x/h3/glide3/src/disst.c
+++ b/glide3x/h3/glide3/src/disst.c
@@ -183,7 +183,7 @@ GR_DIENTRY(grSstSelect, void, ( int whic
     GrErrorCallback( "grSstSelect:  non-existent SST", FXTRUE );
 
   _GlideRoot.current_sst = which;
-  setThreadValue( (FxU32)&_GlideRoot.GCs[_GlideRoot.current_sst] );
+  setThreadValue( (AnyPtr)&_GlideRoot.GCs[_GlideRoot.current_sst] );
 
 #ifdef GLIDE_MULTIPLATFORM
   _GlideRoot.curGCFuncs = _GlideRoot.curGC->gcFuncs;
Index: b/glide3x/h3/glide3/src/distrip.c
===================================================================
--- a/glide3x/h3/glide3/src/distrip.c
+++ b/glide3x/h3/glide3/src/distrip.c
@@ -544,10 +544,10 @@ GR_DIENTRY(grDrawVertexArrayContiguous, 
     else {
       void *b_ptr, *c_ptr;
       while ((int)Count >= 3) {
-        b_ptr = (void *)((FxU32)pointers + stride);
-        c_ptr = (void *)((FxU32)pointers + stride*2);
+        b_ptr = (void *)((AnyPtr)pointers + stride);
+        c_ptr = (void *)((AnyPtr)pointers + stride*2);
         TRISETUP(pointers, b_ptr, c_ptr);
-        pointers = (void *)((FxU32)c_ptr + stride);
+        pointers = (void *)((AnyPtr)c_ptr + stride);
         Count -= 3;
       }
     }
Index: b/glide3x/h3/glide3/src/fifo.c
===================================================================
--- a/glide3x/h3/glide3/src/fifo.c
+++ b/glide3x/h3/glide3/src/fifo.c
@@ -475,7 +475,7 @@ static const char * h3SstIORegNames[] = 
 } ;
 
 
-#define GEN_INDEX(a) ((((FxU32) a) - ((FxU32) gc->reg_ptr)) >> 2)
+#define GEN_INDEX(a) ((((AnyPtr) a) - ((AnyPtr) gc->reg_ptr)) >> 2)
 
 void
 _grFifoWriteDebug(FxU32 addr, FxU32 val, FxU32 fifoPtr)
@@ -833,7 +833,7 @@ _grCommandTransportMakeRoom(const FxI32 
     gc->contextP = 1; 
 #endif
     if (gc->contextP) {
-      FxU32 wrapAddr = 0x00UL;
+      AnyPtr wrapAddr = 0x00UL;
       FxU32 checks;
 
       GR_ASSERT(blockSize > 0);
@@ -879,11 +879,11 @@ _grCommandTransportMakeRoom(const FxI32 
   again:
       /* do we need to stall? */
       {
-        FxU32 lastHwRead = gc->cmdTransportInfo.fifoRead;
+        AnyPtr lastHwRead = gc->cmdTransportInfo.fifoRead;
         FxI32 roomToReadPtr = gc->cmdTransportInfo.roomToReadPtr;
         
         while (roomToReadPtr < blockSize) {
-          FxU32 curReadPtr = HW_FIFO_PTR(FXTRUE);
+          AnyPtr curReadPtr = HW_FIFO_PTR(FXTRUE);
           FxU32 curReadDist = curReadPtr - lastHwRead;
           
           checks++;
@@ -916,8 +916,8 @@ _grCommandTransportMakeRoom(const FxI32 
             checks = 0;
           }
 #endif /* GLIDE_DEBUG */
-          GR_ASSERT((curReadPtr >= (FxU32)gc->cmdTransportInfo.fifoStart) &&
-                    (curReadPtr < (FxU32)gc->cmdTransportInfo.fifoEnd));
+          GR_ASSERT((curReadPtr >= (AnyPtr)gc->cmdTransportInfo.fifoStart) &&
+                    (curReadPtr < (AnyPtr)gc->cmdTransportInfo.fifoEnd));
               
           roomToReadPtr += curReadDist;
               
@@ -929,8 +929,8 @@ _grCommandTransportMakeRoom(const FxI32 
           lastHwRead = curReadPtr;
         }
           
-        GR_ASSERT((lastHwRead >= (FxU32)gc->cmdTransportInfo.fifoStart) &&
-                  (lastHwRead < (FxU32)gc->cmdTransportInfo.fifoEnd));
+        GR_ASSERT((lastHwRead >= (AnyPtr)gc->cmdTransportInfo.fifoStart) &&
+                  (lastHwRead < (AnyPtr)gc->cmdTransportInfo.fifoEnd));
           
         /* Update cached copies */
         gc->cmdTransportInfo.fifoRead = lastHwRead;
@@ -973,7 +973,7 @@ _grCommandTransportMakeRoom(const FxI32 
           
         P6FENCE;
     
-        wrapAddr = (FxU32)gc->cmdTransportInfo.fifoPtr;
+        wrapAddr = (AnyPtr)gc->cmdTransportInfo.fifoPtr;
           
         /* Update roomXXX fields for the actual wrap */
         gc->cmdTransportInfo.roomToReadPtr -= gc->cmdTransportInfo.roomToEnd;
@@ -1002,12 +1002,12 @@ _grCommandTransportMakeRoom(const FxI32 
                 "\tfifoBlock: (0x%X : 0x%X)\n"
                 "\tfifoRoom: (0x%X : 0x%X : 0x%X)\n"
                 "\tfifo hw: (0x%X : 0x%X) : (0x%X : 0x%X : 0x%X)\n",
-                (((FxU32)gc->cmdTransportInfo.fifoPtr - (FxU32)gc->cmdTransportInfo.fifoStart) + 
-                 (FxU32)gc->cmdTransportInfo.fifoOffset),
+                (((AnyPtr)gc->cmdTransportInfo.fifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoStart) + 
+                 (AnyPtr)gc->cmdTransportInfo.fifoOffset),
                 blockSize,
                 gc->cmdTransportInfo.roomToReadPtr, 
                 gc->cmdTransportInfo.roomToEnd, gc->cmdTransportInfo.fifoRoom,
-                HW_FIFO_PTR(FXTRUE) - (FxU32)gc->rawLfb, gc->cmdTransportInfo.fifoRead, 
+                HW_FIFO_PTR(FXTRUE) - (AnyPtr)gc->rawLfb, gc->cmdTransportInfo.fifoRead, 
                 GR_CAGP_GET(depth), GR_CAGP_GET(holeCount), GR_GET(hw->status));
       
       FIFO_ASSERT();
@@ -1047,10 +1047,10 @@ _grH3FifoDump_Linear(const FxU32* const 
 }
 
 
-FxU32
+AnyPtr
 _grHwFifoPtr(FxBool ignored)
 {
-  FxU32 rVal = 0;
+  AnyPtr rVal = 0;
 
   FxU32 status, readPtrL1, readPtrL2;
   GR_DCL_GC;
@@ -1069,7 +1069,7 @@ _grHwFifoPtr(FxBool ignored)
 #endif      
       readPtrL2 = GET(gc->cRegs->cmdFifo0.readPtrL);
     } while (readPtrL1 != readPtrL2);
-    rVal = (((FxU32)gc->cmdTransportInfo.fifoStart) + 
+    rVal = (((AnyPtr)gc->cmdTransportInfo.fifoStart) + 
             readPtrL2 - 
             (FxU32)gc->cmdTransportInfo.fifoOffset);
   }
@@ -1172,8 +1172,24 @@ _reg_group_begin_internal_wax( FxU32 __r
 #endif /* USE_PACKET_FIFO */
 
 #ifdef __linux__
+
+#ifdef __alpha__
+unsigned char _fxget8( unsigned char *pval ) {
+    __asm__ __volatile__("mb": : :"memory");
+    return( *pval );
+}
+unsigned short _fxget16( unsigned short *pval ) {
+    __asm__ __volatile__("mb": : :"memory");
+    return( *pval );
+}
+unsigned int _fxget32( unsigned int *pval ) {
+    __asm__ __volatile__("mb": : :"memory");
+    return( *pval );
+}
+#endif /* __alpha__ */
+
 void
-_grImportFifo(int fifoPtr, int fifoRead) {
+_grImportFifo(AnyPtr fifoPtr, AnyPtr fifoRead) {
   struct cmdTransportInfo* gcFifo;
   FxU32 readPos;
   GR_DCL_GC;
@@ -1191,13 +1207,13 @@ _grImportFifo(int fifoPtr, int fifoRead)
   gcFifo=&gc->cmdTransportInfo;
   readPos=readPos-gcFifo->fifoOffset;
   gcFifo->fifoPtr = gcFifo->fifoStart + (readPos>>2);
-  gcFifo->fifoRead = (FxU32)gcFifo->fifoPtr;
+  gcFifo->fifoRead = (AnyPtr)gcFifo->fifoPtr;
 #else
   gcFifo=&gc->cmdTransportInfo;
   gcFifo->fifoPtr = gc->rawLfb+(fifoPtr>>2);
   gcFifo->fifoRead = ((int)gc->rawLfb)+fifoRead;
 #endif
-  gcFifo->roomToReadPtr = gcFifo->fifoRead-((int)gcFifo->fifoPtr)-FIFO_END_ADJUST-sizeof(FxU32);
+  gcFifo->roomToReadPtr = gcFifo->fifoRead-((AnyPtr)gcFifo->fifoPtr)-FIFO_END_ADJUST-sizeof(FxU32);
   if (gcFifo->roomToReadPtr<0) gcFifo->roomToReadPtr+=gcFifo->fifoSize;
   gcFifo->roomToEnd = gcFifo->fifoSize - 
     ((gcFifo->fifoPtr-gcFifo->fifoStart)<<2) -
@@ -1210,12 +1226,12 @@ _grImportFifo(int fifoPtr, int fifoRead)
 }
 
 void
-_grExportFifo(int *fifoPtr, int *fifoRead) {
+_grExportFifo(FxU32 *fifoPtr, FxU32 *fifoRead) {
   struct cmdTransportInfo* gcFifo;
   GR_DCL_GC;
   gcFifo=&gc->cmdTransportInfo;
   *fifoPtr=(gcFifo->fifoPtr-gc->rawLfb)<<2;
-  *fifoRead=(gcFifo->fifoRead-(int)gc->rawLfb);
+  *fifoRead=(gcFifo->fifoRead-(AnyPtr)gc->rawLfb);
 }
 
 #endif
Index: b/glide3x/h3/glide3/src/fxcmd.h
===================================================================
--- a/glide3x/h3/glide3/src/fxcmd.h
+++ b/glide3x/h3/glide3/src/fxcmd.h
@@ -148,6 +148,12 @@ extern FxU32
 _grGet32(volatile FxU32* const sstAddr);
 #endif /* USE_PACKET_FIFO */
 
+#ifdef __linux__
+void _grImportFifo(AnyPtr fifoPtr, AnyPtr fifoRead);
+void _grExportFifo(FxU32 *fifoPtr, FxU32 *fifoRead);
+void _grInvalidateAll(void);
+#endif /* __linux__ */
+
 #if !USE_PACKET_FIFO
 /* NOTE: fifoFree is the number of entries, each is 8 bytes */
 #define GR_CHECK_FOR_ROOM(n,p) \
@@ -182,7 +188,7 @@ do { \
 /* NB: This should be used sparingly because it does a 'real' hw read
  * which is *SLOW*.
  */
-FxU32 _grHwFifoPtr(FxBool);
+AnyPtr _grHwFifoPtr(FxBool);
 #define HW_FIFO_PTR(a) _grHwFifoPtr(a)
 
 #if FIFO_ASSERT_FULL
@@ -193,7 +199,7 @@ FxU32 _grHwFifoPtr(FxBool);
 #else /* !FIFO_ASSERT_FULL */
 #define FIFO_ASSERT() \
 ASSERT_FAULT_IMMED((FxU32)gc->cmdTransportInfo.fifoRoom < gc->cmdTransportInfo.fifoSize); \
-ASSERT_FAULT_IMMED((FxU32)gc->cmdTransportInfo.fifoPtr < (FxU32)gc->cmdTransportInfo.fifoEnd)
+ASSERT_FAULT_IMMED((AnyPtr)gc->cmdTransportInfo.fifoPtr < (AnyPtr)gc->cmdTransportInfo.fifoEnd)
 #endif /* !FIFO_ASSERT_FULL */
 
 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
@@ -234,7 +240,7 @@ extern void _grBumpNGrind(void);
 #define GR_CHECK_FOR_ROOM(__n, __p) \
 do { \
   const FxU32 writeSize = (__n) + ((__p) * sizeof(FxU32));            /* Adjust for size of hdrs */ \
-  ASSERT(((FxU32)(gc->cmdTransportInfo.fifoPtr) & FIFO_ALIGN_MASK) == 0); /* alignment */ \
+  ASSERT(((AnyPtr)(gc->cmdTransportInfo.fifoPtr) & FIFO_ALIGN_MASK) == 0); /* alignment */ \
   ASSERT(writeSize < gc->cmdTransportInfo.fifoSize - sizeof(FxU32)); \
   FIFO_ASSERT(); \
   if (gc->cmdTransportInfo.fifoRoom < (FxI32)writeSize) { \
@@ -262,7 +268,7 @@ if (gc->cmdTransportInfo.autoBump) {\
 }
 
 #define GR_SET_FIFO_PTR(__n, __p) \
-  gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr; \
+  gc->checkPtr = (AnyPtr)gc->cmdTransportInfo.fifoPtr; \
   gc->checkCounter = ((__n) + ((__p) << 2))
 #else
 #define GR_CHECK_FIFO_PTR() 
@@ -274,7 +280,7 @@ if (gc->cmdTransportInfo.autoBump) {\
                   GDBG_ERROR("GR_ASSERT_SIZE","byte counter should be %d but is %d\n", \
                               gc->expected_counter,gc->counter); \
                 GR_CHECK_FIFO_PTR(); \
-                gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr; \
+                gc->checkPtr = (AnyPtr)gc->cmdTransportInfo.fifoPtr; \
                 gc->checkCounter = 0; \
                 ASSERT(gc->counter == gc->expected_counter); \
                 gc->counter = gc->expected_counter = 0
@@ -649,7 +655,7 @@ do {                                    
     GDBG_INFO(120, "REG_GROUP_SET:\n");                                  \
   }                                                                      \
   GDBG_INFO(120, "\tFile: %s Line %d\n", __FILE__, __LINE__);            \
-  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (FxU32) _regGroupFifoPtr - (FxU32)gc->rawLfb, __val);\
+  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (AnyPtr) _regGroupFifoPtr - (AnyPtr)gc->rawLfb, __val);\
   SET_FIFO(*_regGroupFifoPtr++, (__val)); \
   GR_INC_SIZE(sizeof(FxU32)); \
 } while(0)
@@ -670,7 +676,7 @@ do {                                    
     GDBG_INFO(120, "REG_GROUP_SET:\n");                                  \
   }                                                                      \
   GDBG_INFO(120, "\tFile: %s Line %d\n", __FILE__, __LINE__);            \
-  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (FxU32) _regGroupFifoPtr - (FxU32)gc->rawLfb, __val);\
+  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (AnyPtr) _regGroupFifoPtr - (AnyPtr)gc->rawLfb, __val);\
   SET_FIFO(*_regGroupFifoPtr++, (__val)); \
   GR_INC_SIZE(sizeof(FxU32)); \
 } while(0)
@@ -686,7 +692,7 @@ do { \
   }                                                                      \
   GDBG_INFO(220, "REG_GROUP_SET_WAX:\n");\
   GDBG_INFO(220, "\tFile: %s Line %d\n", __FILE__, __LINE__);\
-  GDBG_INFO(220, "\tfifoPtr: 0x%x, Val: 0x%x\n", (FxU32) _regGroupFifoPtr - (FxU32)gc->rawLfb, __val);\
+  GDBG_INFO(220, "\tfifoPtr: 0x%x, Val: 0x%x\n", (AnyPtr) _regGroupFifoPtr - (AnyPtr)gc->rawLfb, __val);\
   SET_FIFO(*_regGroupFifoPtr++, (__val)); \
   GR_INC_SIZE(sizeof(FxU32)); \
 } while(0)
@@ -716,8 +722,8 @@ do { \
 
 #define REG_GROUP_END() \
   ASSERT(_checkP); \
-  ASSERT((((FxU32)_regGroupFifoPtr - (FxU32)gc->cmdTransportInfo.fifoPtr) >> 2) == _groupNum + 1); \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)_regGroupFifoPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  ASSERT((((AnyPtr)_regGroupFifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr) >> 2) == _groupNum + 1); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)_regGroupFifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = (FxU32*)_regGroupFifoPtr; \
   GDBG_INFO(gc->myLevel + 200, "\tGroupEnd: (0x%X : 0x%X)\n", \
             gc->cmdTransportInfo.fifoPtr, gc->cmdTransportInfo.fifoRoom); \
@@ -730,7 +736,7 @@ do { \
   if (gc->contextP) { \
     FxU32* curFifoPtr = gc->cmdTransportInfo.fifoPtr; \
     FXUNUSED(__base); \
-    GR_ASSERT(((FxU32)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
+    GR_ASSERT(((AnyPtr)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
     GR_CHECK_COMPATABILITY(FN_NAME, \
                            !gc->open, \
                            "Called before grSstWinOpen()"); \
@@ -773,7 +779,7 @@ do { \
   if (gc->contextP) { \
     FxU32* curFifoPtr = gc->cmdTransportInfo.fifoPtr; \
     FXUNUSED(__base); \
-    GR_ASSERT(((FxU32)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
+    GR_ASSERT(((AnyPtr)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
     GR_CHECK_COMPATABILITY(FN_NAME, \
                            !gc->open, \
                            "Called before grSstWinOpen()"); \
@@ -943,27 +949,27 @@ _grH3FifoDump_Linear(const FxU32* const 
   pCount++; \
   GDBG_INFO(gc->myLevel + 200, "\t(0x%X) : V#: 0x%X - P#: 0x%X - ParamVal: (%f : 0x%X)\n", \
             (FxU32)tPackPtr, \
-            ((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
-             (((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
+            ((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
+             (((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
             (((__val) < 786432.875) ? (__val) : ((__val) - 786432.875)), \
             (__floatVal))
 #define SETF_DUMP(__val) \
   pCount++; \
   GDBG_INFO(gc->myLevel + 200, "\t(0x%X) : V#: 0x%X - P#: 0x%X - ParamVal: %f\n", \
             (FxU32)tPackPtr, \
-            ((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
-             (((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
+            ((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
+             (((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
             (((__val) < 786432.875) ? (__val) : ((__val) - 786432.875)))
 #define SET_DUMP(__val) \
   pCount++; \
   GDBG_INFO(gc->myLevel + 200, "\t(0x%X) : V#: 0x%X - P#: 0x%X - ParamVal: 0x%X\n", \
             (FxU32)tPackPtr, \
-            ((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
-             (((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
+            ((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
+             (((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
             (__val))
 #define TRI_ASSERT() \
   GR_ASSERT(pCount == (nVertex * (sVertex >> 2))); \
-  ASSERT(((FxU32)tPackPtr - (FxU32)gc->cmdTransportInfo.fifoPtr) == (nVertex * sVertex) + sizeof(FxU32))
+  ASSERT(((AnyPtr)tPackPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr) == (nVertex * sVertex) + sizeof(FxU32))
 #else /* !GDBG_INFO_ON */
 #define DEBUGFIFODUMP_TRI(__packetAddr)
 #define DEBUGFIFODUMP_LINEAR(__packetAddr)
@@ -1028,7 +1034,7 @@ do { \
 
 #define TRI_END \
   TRI_ASSERT(); \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)tPackPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)tPackPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = tPackPtr; \
   GDBG_INFO(gc->myLevel + 200, "\tTriEnd: (0x%X : 0x%X)\n", tPackPtr, gc->cmdTransportInfo.fifoRoom); \
   FIFO_ASSERT(); \
@@ -1047,12 +1053,12 @@ do { \
   GR_CHECK_COMPATABILITY(FN_NAME, \
                          !gc->open, \
                          "Called before grSstWinOpen()"); \
-  GR_ASSERT(((FxU32)(packetPtr) & FIFO_ALIGN_MASK) == 0);        /* alignment */ \
+  GR_ASSERT(((AnyPtr)(packetPtr) & FIFO_ALIGN_MASK) == 0);        /* alignment */ \
   GR_ASSERT((__numWords) > 0);                                   /* packet size */ \
   GR_ASSERT((__numWords) < ((0x01 << 19) - 2)); \
   GR_ASSERT((((FxU32)(__numWords) + 2) << 2) <= (FxU32)gc->cmdTransportInfo.fifoRoom); \
-  GR_ASSERT(((FxU32)packetPtr + (((__numWords) + 2) << 2)) < \
-            (FxU32)gc->cmdTransportInfo.fifoEnd); \
+  GR_ASSERT(((AnyPtr)packetPtr + (((__numWords) + 2) << 2)) < \
+            (AnyPtr)gc->cmdTransportInfo.fifoEnd); \
   GR_ASSERT((hdr2 & 0xE0000000UL) == 0x00UL); \
   GR_ASSERT(((__addr) & 0x03UL) == 0x00UL); \
   FIFO_ASSERT(); \
@@ -1097,8 +1103,8 @@ do { \
 
 #define FIFO_LINEAR_WRITE_END \
   DEBUGFIFODUMP_LINEAR(gc->cmdTransportInfo.fifoPtr); \
-  GR_ASSERT((((FxU32)packetPtr - (FxU32)gc->cmdTransportInfo.fifoPtr) >> 2) == __writeSize + 2); \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)packetPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  GR_ASSERT((((AnyPtr)packetPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr) >> 2) == __writeSize + 2); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)packetPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = packetPtr; \
   GDBG_INFO(gc->myLevel + 200, "\tLinearEnd: (0x%X : 0x%X)\n", \
             packetPtr, gc->cmdTransportInfo.fifoRoom); \
@@ -1512,7 +1518,7 @@ GR_CHECK_SIZE()
     } \
     else { \
       FxU32 argb; \
-      argb = *((FxU32 *)((int)_s + i)) & 0x00ffffff; \
+      argb = *((FxU32 *)((long)_s + i)) & 0x00ffffff; \
       TRI_SETF(*((float *)&argb)); \
       dataElem++; \
       i = gc->tsuDataList[dataElem]; \
Index: b/glide3x/h3/glide3/src/fxglide.h
===================================================================
--- a/glide3x/h3/glide3/src/fxglide.h
+++ b/glide3x/h3/glide3/src/fxglide.h
@@ -1053,7 +1053,7 @@ typedef struct GrGC_s
           SET(*curFifoPtr++, *curPktData++); \
         } \
         GR_INC_SIZE((__writeCount) * sizeof(FxU32)); \
-        gc->cmdTransportInfo.fifoRoom -= ((FxU32)curFifoPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+        gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)curFifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
         gc->cmdTransportInfo.fifoPtr = curFifoPtr; \
       } \
       GR_CHECK_SIZE(); \
@@ -1172,7 +1172,7 @@ typedef struct GrGC_s
                           */
     
     FxU32* fifoPtr;      /* Current write pointer into fifo */
-    FxU32  fifoRead;     /* Last known hw read ptr. 
+    AnyPtr fifoRead;     /* Last known hw read ptr.
                           * If on an sli enabled system this will be
                           * the 'closest' hw read ptr of the sli
                           * master and slave.
@@ -1257,12 +1257,13 @@ typedef struct GrGC_s
     nBuffers,
     curBuffer,
     frontBuffer,
-    backBuffer,
+    backBuffer;
+  AnyPtr
     buffers[4],
     lfbBuffers[4];              /* Tile relative addresses of the color/aux
                                  * buffers for lfbReads.
                                  */  
-  FxU32 lockPtrs[2];        /* pointers to locked buffers */
+  AnyPtr lockPtrs[2];        /* pointers to locked buffers */
   FxU32 fbStride;
 
   struct {
@@ -1297,7 +1298,7 @@ typedef struct GrGC_s
   FxI32 expected_counter;       /* the number of bytes expected to be sent */
 
   FxU32 checkCounter;
-  FxU32 checkPtr;
+  AnyPtr checkPtr;
    
   FxVideoTimingInfo* vidTimings;/* init code overrides */
 
@@ -1489,6 +1490,10 @@ extern GrGCFuncs _curGCFuncs;
 #  define P6FENCE __eieio()
 #elif defined(__GNUC__) && defined(__i386__)
 #define P6FENCE asm("xchg %%eax, %0" : : "m" (_GlideRoot.p6Fencer) : "eax");
+#elif defined(__GNUC__) && defined(__ia64__)
+#define P6FENCE asm volatile("mf.a" ::: "memory")
+#elif defined(__GNUC__) && defined(__alpha__)
+#define P6FENCE asm volatile("mb" ::: "memory")
 #else  /* !defined ( P6FENCE ) */
 #  error "P6 Fencing code needs to be added for this compiler"
 #endif /* !defined ( P6FENCE ) */
@@ -1824,7 +1829,7 @@ getThreadValueFast() {
 #endif
 
 #ifdef __linux__
-extern FxU32 threadValueLinux;
+extern AnyPtr threadValueLinux;
 #define getThreadValueFast() threadValueLinux
 #endif
 
@@ -1839,9 +1844,9 @@ void 
 initThreadStorage( void );
 
 void 
-setThreadValue( FxU32 value );
+setThreadValue( AnyPtr value );
 
-FxU32
+AnyPtr
 getThreadValueSLOW( void );
 
 void 
@@ -2189,7 +2194,7 @@ void i3(void);
 #define HW_TEX_PTR(__b)        ((FxU32*)(((FxU32)(__b)) + HW_TEXTURE_OFFSET))   
 
 /* access a floating point array with a byte index */
-#define FARRAY(p,i)    (*(float *)((i)+(int)(p)))
+#define FARRAY(p,i)    (*(float *)((i)+(long)(p)))
 #define ArraySize(__a) (sizeof(__a) / sizeof((__a)[0]))
 
 #if GDBG_INFO_ON
Index: b/glide3x/h3/glide3/src/g3df.c
===================================================================
--- a/glide3x/h3/glide3/src/g3df.c
+++ b/glide3x/h3/glide3/src/g3df.c
@@ -70,6 +70,7 @@
  * Added GR_DIENTRY for di glide functions
 **
 */
+#include <ctype.h>
 #include <stdio.h>
 #include <string.h>
 #include <ctype.h>
Index: b/glide3x/h3/glide3/src/gaa.c
===================================================================
--- a/glide3x/h3/glide3/src/gaa.c
+++ b/glide3x/h3/glide3/src/gaa.c
@@ -378,8 +378,8 @@ aaVpDrawArrayEdgeSense(float *a, float *
   }
   else {
     ia = gc->state.vData.pargbInfo.offset;
-    *((FxU32 *)&v1a)=*((FxU32 *)((int)a + ia))&0x00ffffff;
-    *((FxU32 *)&v2a)=*((FxU32 *)((int)b + ia))&0x00ffffff;
+    *((FxU32 *)&v1a)=*((FxU32 *)((long)a + ia))&0x00ffffff;
+    *((FxU32 *)&v2a)=*((FxU32 *)((long)b + ia))&0x00ffffff;
   }
 
   {
@@ -577,7 +577,7 @@ _grAADrawPoints(FxI32 mode, FxI32 count,
   FxU32 ia;
   FxU32 i;
   FxU32 vsize;
-  FxI32 stride = mode;
+  FxI32 stride;
   FxU32 tmp_cullStripHdr;
 
   GDBG_INFO(94,"_grAADrawPoints(0x%x)\n",e);
@@ -585,8 +585,10 @@ _grAADrawPoints(FxI32 mode, FxI32 count,
   GDBG_INFO_MORE(gc->myLevel, "(count = %d, pointers = 0x%x)\n",
                  count, pointers);
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
   GR_FLUSH_STATE();
 
@@ -678,7 +680,7 @@ _grAADrawPoints(FxI32 mode, FxI32 count,
               FxU32 argb;
               
               if (i == ia) {
-                argb = *((FxU32 *)((int)e + i)) & 0x00ffffff;
+                argb = *((FxU32 *)((long)e + i)) & 0x00ffffff;
                 TRI_SETF(*((float *)&argb));
               }
               else {
@@ -801,7 +803,7 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
   FxU32 ia, vNum = 0;
   FxU32 vsize;
   FxU32 sCount;
-  FxI32 stride = mode;
+  FxI32 stride;
   FxU32 tmp_cullStripHdr;
 
   GDBG_INFO(95,"_grAADrawLineStrip(count = %d, pointers = 0x%x)\n",
@@ -817,8 +819,11 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
 
   GR_FLUSH_STATE();
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
+
   if (ltype == GR_LINES)
     sCount = count >> 1; /* line list */
   else
@@ -855,8 +860,8 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
         ady = -ady;
       
       if (gc->state.vData.colorType != GR_FLOAT) {
-        *((FxU32 *)&v1a)=*((FxU32 *)((int)v1 + ia))&0x00ffffff;
-        *((FxU32 *)&v2a)=*((FxU32 *)((int)v2 + ia))&0x00ffffff;
+        *((FxU32 *)&v1a)=*((FxU32 *)((long)v1 + ia))&0x00ffffff;
+        *((FxU32 *)&v2a)=*((FxU32 *)((long)v2 + ia))&0x00ffffff;
       }
       
       if (adx >= ady) {           /* X major line */
@@ -1062,8 +1067,8 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
         ady = -ady;
       /*
       if (gc->state.vData.colorType != GR_FLOAT) {
-        *((FxU32 *)&v1a)=*((FxU32 *)((int)v1 + ia))&0x00ffffff;
-        *((FxU32 *)&v2a)=*((FxU32 *)((int)v2 + ia))&0x00ffffff;
+        *((FxU32 *)&v1a)=*((FxU32 *)((long)v1 + ia))&0x00ffffff;
+        *((FxU32 *)&v2a)=*((FxU32 *)((long)v2 + ia))&0x00ffffff;
       }
       */
       
@@ -1255,8 +1260,8 @@ aaDrawArrayEdgeSense(float *a, float *b,
   }
   else {
     ia = gc->state.vData.pargbInfo.offset;
-    *((FxU32 *)&v1a)=*((FxU32 *)((int)a + ia))&0x00ffffff;
-    *((FxU32 *)&v2a)=*((FxU32 *)((int)b + ia))&0x00ffffff;
+    *((FxU32 *)&v1a)=*((FxU32 *)((long)a + ia))&0x00ffffff;
+    *((FxU32 *)&v2a)=*((FxU32 *)((long)b + ia))&0x00ffffff;
   }
 
   {
@@ -1332,7 +1337,7 @@ _grAADrawTriangles(FxI32 mode, FxI32 tty
   float **lPtr = (float **)pointers;
   FxI32 tCount = 3;
   FxU32 fbzModeOld;                 /* Squirrel away current fbzMode */
-  FxI32 stride = mode;
+  FxI32 stride;
   FxI32 xindex = (gc->state.vData.vertexInfo.offset >> 2);
   FxI32 yindex = xindex + 1;
 
@@ -1349,8 +1354,10 @@ _grAADrawTriangles(FxI32 mode, FxI32 tty
   /* gc->state.invalid |= fbzModeBIT; */
   GR_FLUSH_STATE();
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
   /* backfaced or zero area */
   while (tCount <= count) {
@@ -1505,7 +1512,7 @@ _grAAVpDrawTriangles(FxI32 mode, FxI32 t
   float **lPtr = (float **)pointers;
   FxI32 tCount = 3;
   FxU32 fbzModeOld;                 /* Squirrel away current fbzMode */
-  FxI32 stride = mode;
+  FxI32 stride;
   FxI32 xindex = (gc->state.vData.vertexInfo.offset >> 2);
   FxI32 yindex = xindex + 1;
 
@@ -1522,8 +1529,10 @@ _grAAVpDrawTriangles(FxI32 mode, FxI32 t
   /* gc->state.invalid |= fbzModeBIT; */
   GR_FLUSH_STATE();
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
   /* backfaced or zero area */
   while (tCount <= count) {
@@ -1687,7 +1696,7 @@ _grAADrawVertexList(FxU32 type, FxI32 mo
   float *v[3];
   FxBool flip = FXFALSE;
   FxU32 fbzModeOld;                 /* Squirrel away current fbzMode */
-  FxI32 stride = mode;
+  FxI32 stride;
 
   if (sCount <= 2) return;
 
@@ -1698,8 +1707,10 @@ _grAADrawVertexList(FxU32 type, FxI32 mo
   gc->state.shadow.fbzMode &= ~(SST_ZAWRMASK);
   /* gc->state.invalid |= fbzModeBIT; */
   GR_FLUSH_STATE();
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
   sCount-=2;
   if (type == kSetupFan) {
Index: b/glide3x/h3/glide3/src/gdraw.c
===================================================================
--- a/glide3x/h3/glide3/src/gdraw.c
+++ b/glide3x/h3/glide3/src/gdraw.c
@@ -232,14 +232,15 @@ GR_ENTRY(grDrawPoint, void, (const void 
 
 GR_ENTRY(grDrawLine, void, (const void *a, const void *b))
 {
+  const void *vertices[2] = {a, b};
 #define FN_NAME "grDrawLine"
   GR_BEGIN_NOFIFOCHECK(FN_NAME, 91);
   GDBG_INFO_MORE(gc->myLevel, "(a = 0x%x, b = 0x%x)\n", a, b);
 
   if (gc->state.grEnableArgs.primitive_smooth_mode & GR_AA_ORDERED_LINES_MASK)
-    _grAADrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, (void *)&a);
+    _grAADrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, vertices);
   else
-    _grDrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, (void *)&a);
+    _grDrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, vertices);
 #undef FN_NAME
 } /* grDrawLine */
 
@@ -323,7 +324,7 @@ GR_ENTRY(grDrawTriangle, void, (const vo
   GR_INC_SIZE(sizeof(FxU32))
 
 #define DA_END \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)packetPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)packetPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = packetPtr; \
   FIFO_ASSERT(); \
 }
@@ -348,7 +349,7 @@ _grDrawPoints(FxI32 mode, FxI32 count, v
    * except the data set up is from the pointer array and 
    * its data layout
    */
-  FxI32 stride = mode;
+  FxI32 stride;
 
   /* we snap to an integer by adding a large enough number that it
    * shoves all fraction bits off the right side of the mantissa.
@@ -382,8 +383,10 @@ _grDrawPoints(FxI32 mode, FxI32 count, v
    */
 #define POINTS_BUFFER  100
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
   if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS) {
     while (count > 0) {
@@ -573,7 +576,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
   int j;
   FxI32 sCount;
   FxU32 vertexParamOffset;
-  FxI32 stride = mode;
+  FxI32 stride;
 
 #define  DX gc->pool.ftemp1
 #define ADY gc->pool.ftemp2
@@ -589,8 +592,11 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
 
 #define LINES_BUFFER  100
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
+
   if (ltype == GR_LINES)
     sCount = count >> 1; /* line list */
   else
@@ -618,16 +624,16 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
         ** compute absolute deltas and draw from low Y to high Y
         */
         ADY = FARRAY(b, gc->state.vData.vertexInfo.offset+4) - FARRAY(a, gc->state.vData.vertexInfo.offset+4);
-        i = *(long *)&ADY;
+        i = *(int *)&ADY;
         if (i < 0) {
           float *tv;
           tv = a; a = b; b = tv;
           i ^= 0x80000000;            /* ady = -ady; */
-          (*(long *)&ADY) = i;
+          (*(int *)&ADY) = i;
         }
         
         DX = FARRAY(b, gc->state.vData.vertexInfo.offset) - FARRAY(a, gc->state.vData.vertexInfo.offset);
-        j = *(long *)&DX;
+        j = *(int *)&DX;
         if (j < 0) {
           j ^= 0x80000000;            /* adx = -adx; */
         }
@@ -797,7 +803,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
         ** compute absolute deltas and draw from low Y to high Y
         */
         ADY = tmp2 - tmp1;
-        i = *(long *)&ADY;
+        i = *(int *)&ADY;
         if (i < 0) {
           float *tv;          
           owa = oowb; owb = oowa;
@@ -805,7 +811,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
           fby = tmp1;
           tv = a; a = b; b = tv;
           i ^= 0x80000000;            /* ady = -ady; */
-          (*(long *)&ADY) = i;
+          (*(int *)&ADY) = i;
         }
         fax = FARRAY(a, gc->state.vData.vertexInfo.offset)
           *owa*gc->state.Viewport.hwidth+gc->state.Viewport.ox;
@@ -813,7 +819,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
           *owb*gc->state.Viewport.hwidth+gc->state.Viewport.ox;
         
         DX = fbx - fax;
-        j = *(long *)&DX;
+        j = *(int *)&DX;
         if (j < 0) {
           j ^= 0x80000000;            /* adx = -adx; */
         }
@@ -901,7 +907,7 @@ _grDrawTriangles_Default(FxI32 mode, FxI
     vSize,
 #endif
     k;
-  FxI32 stride = mode;
+  FxI32 stride;
   float *vPtr;
 
   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
@@ -917,8 +923,10 @@ _grDrawTriangles_Default(FxI32 mode, FxI
   GDBG_INFO(110, "%s:  paramMask = 0x%x\n", FN_NAME, gc->cmdTransportInfo.paramMask);
 #endif
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
 
   gc->stats.trisProcessed+=(count/3);
Index: b/glide3x/h3/glide3/src/gerror.c
===================================================================
--- a/glide3x/h3/glide3/src/gerror.c
+++ b/glide3x/h3/glide3/src/gerror.c
@@ -280,7 +280,7 @@ _grAssert(char *exp, char *fileName, int
     
     gdbg_printf("Command Fifo:\n");
     gdbg_printf("\tSoftware:\n");
-    gdbg_printf("\t\tfifoPtr:           0x%X\n", (FxU32)gc->cmdTransportInfo.fifoPtr - (FxU32) gc->rawLfb);
+    gdbg_printf("\t\tfifoPtr:           0x%X\n", (AnyPtr)gc->cmdTransportInfo.fifoPtr - (AnyPtr) gc->rawLfb);
     gdbg_printf("\t\tfifoOffset:        0x%X\n", gc->cmdTransportInfo.fifoOffset); 
     gdbg_printf("\t\tfifoEnd:           0x%X\n", gc->cmdTransportInfo.fifoEnd - gc->rawLfb);
     gdbg_printf("\t\tfifoSize:          0x%X\n", gc->cmdTransportInfo.fifoSize); 
@@ -290,7 +290,7 @@ _grAssert(char *exp, char *fileName, int
 
     if ( !gc->windowed ) {
       gdbg_printf("\tHardware:\n");
-      gdbg_printf("\t\treadPtrL:          0x%X\n", HW_FIFO_PTR(FXTRUE) - (FxU32)gc->rawLfb);
+      gdbg_printf("\t\treadPtrL:          0x%X\n", HW_FIFO_PTR(FXTRUE) - (AnyPtr)gc->rawLfb);
       gdbg_printf("\t\tdepth:             0x%X\n", GR_CAGP_GET(depth));
       gdbg_printf("\t\tholeCount:         0x%X\n", GR_CAGP_GET(holeCount));
       gdbg_printf("\t\tbaseAddrL:         0x%X\n", GR_CAGP_GET(baseAddrL));
Index: b/glide3x/h3/glide3/src/gglide.c.dri
===================================================================
--- a/glide3x/h3/glide3/src/gglide.c.dri
+++ b/glide3x/h3/glide3/src/gglide.c.dri
@@ -1091,8 +1091,8 @@ GR_ENTRY(grBufferSwap, void, (FxU32 swap
     for ( i = 0; i < MAX_BUFF_PENDING && j == -1; i++) {
       if (gc->bufferSwaps[i] == 0xffffffff) {
         gc->bufferSwaps[i] =
-          (FxU32) gc->cmdTransportInfo.fifoPtr -
-          (FxU32) gc->cmdTransportInfo.fifoStart; 
+          (AnyPtr) gc->cmdTransportInfo.fifoPtr -
+          (AnyPtr) gc->cmdTransportInfo.fifoStart; 
         j = i;
       }
     }
@@ -1193,8 +1193,8 @@ GR_ENTRY(grDRIBufferSwap, void, (FxU32 s
     for ( i = 0; i < MAX_BUFF_PENDING && j == -1; i++) {
       if (gc->bufferSwaps[i] == 0xffffffff) {
         gc->bufferSwaps[i] =
-          (FxU32) gc->cmdTransportInfo.fifoPtr -
-          (FxU32) gc->cmdTransportInfo.fifoStart; 
+          (AnyPtr) gc->cmdTransportInfo.fifoPtr -
+          (AnyPtr) gc->cmdTransportInfo.fifoStart; 
         j = i;
       }
     }
@@ -1236,7 +1236,7 @@ GR_ENTRY(grDRIBufferSwap, void, (FxU32 s
       REG_GROUP_SET_WAX(hw, srcXY, x | ((driInfo.y+(y-driInfo.y))<<16));
       REG_GROUP_SET_WAX(hw, dstSize, (w&0x1FFF)|((h&0x1FFF)<<16));
       REG_GROUP_SET_WAX(hw, dstXY, (x&0x1FFF) | ((y&0x1FFF)<<16));
-      REG_GROUP_SET_WAX(hw, command, (0xCC<<24) | 0x1 | BIT(8));
+      REG_GROUP_SET_WAX(hw, command, (0xCCu<<24) | 0x1 | BIT(8));
       REG_GROUP_END();
     } while (cnt);
 
@@ -2168,7 +2168,7 @@ GR_ENTRY(grGlideShutdown, void, (void))
            * continuing so that any internal glide calls have a valid
            * gc from tls via GR_DCL_GC. F*ck this up at your own peril.
            */
-          setThreadValue((FxU32)gc);
+          setThreadValue((AnyPtr)gc);
 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
           /* Flush any remaining commands and cleanup any per gc state */
           grSurfaceReleaseContext((GrContext_t)gc);
Index: b/glide3x/h3/glide3/src/glfb.c.dri
===================================================================
--- a/glide3x/h3/glide3/src/glfb.c.dri
+++ b/glide3x/h3/glide3/src/glfb.c.dri
@@ -712,7 +712,7 @@ _grLfbWriteRegion(FxBool pixPipelineP,
     case GR_LFB_SRC_FMT_ZA16:
       dstData = (FxU32*)(((FxU16*)dstData) + dst_x);
       length  = src_width * 2;
-      aligned = !((int)dstData&0x2);
+      aligned = !((long)dstData&0x2);
       srcJump = src_stride - length;
       dstJump = info.strideInBytes - length;
       if (aligned) {
@@ -917,7 +917,7 @@ GR_ENTRY(grLfbReadRegion, FxBool, (GrBuf
     length   = src_width * 2;
     dstJump  = dst_stride - length;
     srcJump  = info.strideInBytes - length;
-    aligned  = !((int)srcData&0x2);
+    aligned  = !((long)srcData&0x2);
     odd      = (src_y+src_height) & 0x1;
     
     if (aligned) {
Index: b/glide3x/h3/glide3/src/glide.h
===================================================================
--- a/glide3x/h3/glide3/src/glide.h
+++ b/glide3x/h3/glide3/src/glide.h
@@ -56,7 +56,7 @@ typedef FxU32 GrMipMapId_t;
 typedef FxU32 GrStipplePattern_t;
 #endif /* __linux__ */
 typedef FxU8  GrFog_t;
-typedef FxU32 GrContext_t;
+typedef AnyPtr GrContext_t;
 typedef int (FX_CALL *GrProc)();
 
 /*
Index: b/glide3x/h3/glide3/src/gpci.c
===================================================================
--- a/glide3x/h3/glide3/src/gpci.c
+++ b/glide3x/h3/glide3/src/gpci.c
@@ -421,14 +421,14 @@ static GrTriSetupProc _triSetupProcs[][2
   {
     /* Window coords */
     {
-      { _trisetup_null, _trisetup_null },
-      { _trisetup_null, _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
     },
 
     /* Clip coordinates */
     {
-      { _trisetup_null, _trisetup_null },
-      { _trisetup_null, _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
     },
   },
 };
@@ -1027,7 +1027,7 @@ DllMain(HANDLE hInst, ULONG  ul_reason_f
       GR_DCL_GC;
 
       /* If there is no current gc in tls then set the current context. */
-      if (gc == NULL) setThreadValue((FxU32)&_GlideRoot.GCs[_GlideRoot.current_sst]);
+      if (gc == NULL) setThreadValue((AnyPtr)&_GlideRoot.GCs[_GlideRoot.current_sst]);
     }
     break;
   case DLL_THREAD_DETACH:
Index: b/glide3x/h3/glide3/src/gsst.c.dri
===================================================================
--- a/glide3x/h3/glide3/src/gsst.c.dri
+++ b/glide3x/h3/glide3/src/gsst.c.dri
@@ -756,8 +756,8 @@ initGC ( GrGC *gc ) 
     gc->bufferSwaps[t] = 0xffffffff;
   }
   
-  gc->bufferSwaps[0] = ((FxU32) gc->cmdTransportInfo.fifoPtr -
-                        (FxU32) gc->cmdTransportInfo.fifoStart);
+  gc->bufferSwaps[0] = ((AnyPtr) gc->cmdTransportInfo.fifoPtr -
+                        (AnyPtr) gc->cmdTransportInfo.fifoStart);
   
   gc->swapsPending = 1;
   
@@ -946,7 +946,7 @@ GR_ENTRY(grSstWinOpen, GrContext_t, ( Fx
    * current gc. This gc is valid for all threads in the fullscreen
    * context.
    */
-  setThreadValue( (FxU32)&_GlideRoot.GCs[_GlideRoot.current_sst] );
+  setThreadValue( (AnyPtr)&_GlideRoot.GCs[_GlideRoot.current_sst] );
   
   {
     /* Partial Argument Validation */
@@ -1076,12 +1076,12 @@ GR_ENTRY(grSstWinOpen, GrContext_t, ( Fx
     for (buffer = 0; buffer < nColBuffers; buffer++) {
       gc->buffers[buffer] = bufInfo->colBuffStart[buffer];
       GDBG_INFO(80, "Buffer %d:  Start: 0x%x\n", buffer, gc->buffers[buffer]);
-      gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr[buffer];
+      gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr[buffer];
     }
     if (nAuxBuffers != 0) {
       gc->buffers[buffer] = bufInfo->auxBuffStart;
       GDBG_INFO(80, "Aux Buffer:  Start: 0x%x\n", gc->buffers[buffer]);
-      gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr[buffer];
+      gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr[buffer];
     }
   
     vInfo->hWnd     = gc->grHwnd;
@@ -1190,7 +1190,7 @@ GR_ENTRY(grSstWinOpen, GrContext_t, ( Fx
     gc->tBuffer.bufBPP = 0xffffffff; /* Don't matter to me */
 
     GDBG_INFO(1, "autoBump: 0x%x\n", _GlideRoot.environment.autoBump);
-    if ((gc->cmdTransportInfo.autoBump = _GlideRoot.environment.autoBump)) {
+    if ((gc->cmdTransportInfo.autoBump = _GlideRoot.environment.autoBump)!=0) {
       if (!hwcInitFifo( bInfo, gc->cmdTransportInfo.autoBump)) {
         hwcRestoreVideo(bInfo);
         GrErrorCallback(hwcGetErrorString(), FXFALSE);
@@ -1226,7 +1226,7 @@ GR_ENTRY(grSstWinOpen, GrContext_t, ( Fx
     gc->tmu_state[0].total_mem = gc->tramSize;
 #else
     /* gc->fbOffset               = (FxU32)fxHalFbiGetMemory((SstRegs*)gc->reg_ptr); */
-    gc->fbOffset                  = (FxU32)gc->rawLfb;
+    gc->fbOffset                  = (AnyPtr)gc->rawLfb;
     gc->tmuMemInfo[0].tramOffset  = 0x200000;
     gc->tmuMemInfo[0].tramSize    = 0x200000;
     gc->tmuMemInfo[1].tramOffset  = gc->tmuMemInfo[0].tramSize + gc->tmuMemInfo[0].tramOffset;
@@ -1440,7 +1440,7 @@ GR_ENTRY(grSstWinOpen, GrContext_t, ( Fx
               gcFifo->fifoPtr ); 
 
 #ifdef __linux__
-    _grImportFifo(*driInfo.fifoPtr, *driInfo.fifoRead);
+    _grImportFifo((AnyPtr)*driInfo.fifoPtr, (AnyPtr)*driInfo.fifoRead);
 #endif
     
     /* The hw is now in a usable state from the fifo macros.
@@ -1591,7 +1591,7 @@ GR_ENTRY(grSstWinClose, FxBool, (GrConte
    * the tls gc explicitly otherwise other whacky-ness (read 'random
    * crashes' will ensue). 
    */
-  setThreadValue((FxU32)gc);
+  setThreadValue((AnyPtr)gc);
   if ((gc != NULL) && gc->open) grFlush();
 
   /* Make sure that the user specified gc is not whacked */
@@ -1856,8 +1856,8 @@ GR_ENTRY(grFlush, void, (void))
   if ( gc->windowed ) {
 #ifdef GLIDE_INIT_HWC
     GDBG_INFO(gc->myLevel + 200, FN_NAME": cmdSize(0x%X)\n",
-              ((FxU32)gc->cmdTransportInfo.fifoPtr - 
-               (FxU32)gc->cmdTransportInfo.hwcFifoInfo.cmdBuf.baseAddr));
+              ((AnyPtr)gc->cmdTransportInfo.fifoPtr - 
+               (AnyPtr)gc->cmdTransportInfo.hwcFifoInfo.cmdBuf.baseAddr));
 #endif
     _FifoFlush();
   } else if (!gc->cmdTransportInfo.autoBump) {
Index: b/glide3x/h3/glide3/src/gstrip.c
===================================================================
--- a/glide3x/h3/glide3/src/gstrip.c
+++ b/glide3x/h3/glide3/src/gstrip.c
@@ -149,7 +149,7 @@ _grDrawVertexList(FxU32 pktype, FxU32 ty
   ** simplified code
   */
   FxU32 vSize;
-  FxI32 stride = mode;
+  FxI32 stride;
 
   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
 
@@ -159,8 +159,10 @@ _grDrawVertexList(FxU32 pktype, FxU32 ty
   GR_FLUSH_STATE();
 
   vSize = gc->state.vData.vSize;
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof (float *) / sizeof (float);
 
   /* Draw the first (or possibly only) set.  This is necessary because
      the packet is 3_BDDDDDD, and in the next set, the packet is
Index: b/glide3x/h3/glide3/src/gtexdl.c
===================================================================
--- a/glide3x/h3/glide3/src/gtexdl.c
+++ b/glide3x/h3/glide3/src/gtexdl.c
@@ -417,7 +417,7 @@ GR_DDFUNC(_grTexDownloadPalette,
         while(i < start + slopCount) {
           FxU32 entry;
           
-          entry = (0x80000000 | ((i & 0xFE) << 23) | pal->data[i] & 0xFFFFFF);
+          entry = (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF));
           
           gc->state.shadow.paletteRow[i>>3].data[i&7] = entry;
           REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)], entry );
@@ -435,7 +435,7 @@ GR_DDFUNC(_grTexDownloadPalette,
         while(i < endIndex) {
           FxU32 entry;
           
-          entry = (0x80000000 | ((i & 0xFE) << 23) | pal->data[i] & 0xFFFFFF);
+          entry = (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF));
           
           gc->state.shadow.paletteRow[i>>3].data[i&7] = entry;
           REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)], entry );
@@ -454,7 +454,7 @@ GR_DDFUNC(_grTexDownloadPalette,
         while(i <= end) {
           FxU32 entry;
           
-          entry = (0x80000000 | ((i & 0xFE) << 23) | pal->data[i] & 0xFFFFFF);
+          entry = (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF));
           
           gc->state.shadow.paletteRow[i>>3].data[i&7] = entry;
           REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)], entry );
Index: b/glide3x/h3/glide3/src/gthread.c
===================================================================
--- a/glide3x/h3/glide3/src/gthread.c
+++ b/glide3x/h3/glide3/src/gthread.c
@@ -63,13 +63,13 @@ initThreadStorage( void ) 
 
 } /* initThreadStorage */
 
-void setThreadValue( FxU32 value ) {
+void setThreadValue( AnyPtr value ) {
     GR_CHECK_F( "setThreadValue", !threadInit, "Thread storage not initialized\n" );
     TlsSetValue( _GlideRoot.tlsIndex, (void*)value );
 }
 
 #pragma warning (4:4035)        /* No return value */
-FxU32 getThreadValueSLOW( void ) {
+AnyPtr getThreadValueSLOW( void ) {
     GR_CHECK_F( "getThreadValue", !threadInit, "Thread storage not initialized\n" );
 
 #if 0
@@ -116,18 +116,18 @@ void endCriticalSection( void ) {
 #include "fxglide.h"
 #include "fxcmd.h"
 
-FxU32 _threadValueMacOS;
+AnyPtr _threadValueMacOS;
 
 void initThreadStorage(void)
 {
 }
 
-void setThreadValue( FxU32 value )
+void setThreadValue( AnyPtr value )
 {
 	_threadValueMacOS = value;
 }
 
-FxU32 getThreadValueSLOW( void )
+AnyPtr getThreadValueSLOW( void )
 {
 	return _threadValueMacOS;
 }
@@ -157,18 +157,18 @@ void endCriticalSection(void)
 #include "fxglide.h"
 #include "fxcmd.h"
 
-FxU32 threadValueLinux;
+AnyPtr threadValueLinux;
 
 void initThreadStorage(void)
 {
 }
 
-void setThreadValue( FxU32 value )
+void setThreadValue( AnyPtr value )
 {
 	threadValueLinux = value;
 }
 
-FxU32 getThreadValueSLOW( void )
+AnyPtr getThreadValueSLOW( void )
 {
 	return threadValueLinux;
 }
Index: b/glide3x/h3/glide3/src/xdraw2.inc.S
===================================================================
--- a/glide3x/h3/glide3/src/xdraw2.inc.S
+++ b/glide3x/h3/glide3/src/xdraw2.inc.S
@@ -249,7 +249,7 @@ LOCAL(nocull):
 	push %edi	/*  save caller's register variable */
 	push %esi	/*  save caller's register variable  */
 
-	mov _gc-8(%esp) , gc	/*  gc on stack (NOT!!! in edx) from caller */
+	mov %edx , gc	/*  gc in edx from caller */
 	push %ebx	/*  save caller's register variable */
 
 	push %ebp	/*  save frame pointer */
Index: b/glide3x/h3/glide3/src/xtexdl_def.c
===================================================================
--- a/glide3x/h3/glide3/src/xtexdl_def.c
+++ b/glide3x/h3/glide3/src/xtexdl_def.c
@@ -216,7 +216,7 @@ _grTexDownload_Default_8_4(struct GrGC_s
       const FxU32 t0 = *(const FxU32*)src8;
       
       GDBG_INFO(195, "s = %d, t= %d, address = 0x%x\n", s, t,
-                (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
+                (AnyPtr) tex_address - (AnyPtr) gc->tex_ptr + 0x200000);
       
       LINEAR_WRITE_SET_8(tex_address, t0);
       
@@ -254,7 +254,7 @@ _grTexDownload_Default_8_WideS(struct Gr
         t1 = *(const FxU32*)(src8 + 4);
       
       GDBG_INFO(195, "s = %d, t= %d, address = 0x%x\n", s, t,
-                (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
+                (AnyPtr) tex_address - (AnyPtr) gc->tex_ptr + 0x200000);
       
       LINEAR_WRITE_SET_8(tex_address + 0, t0);
       LINEAR_WRITE_SET_8(tex_address + 4, t1);
@@ -354,7 +354,7 @@ _grTexDownload_Default_16_WideS(struct G
       const FxU32 t1 = *(const FxU32*)(src16 + 2);
       
       GDBG_INFO(195, "s = %d, t= %d, address = 0x%x\n", s, t,
-                (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
+                (AnyPtr) tex_address - (AnyPtr) gc->tex_ptr + 0x200000);
       
       LINEAR_WRITE_SET_16(tex_address + 0, t0);
       LINEAR_WRITE_SET_16(tex_address + 4, t1);
Index: b/glide3x/h3/incsrc/fxhal.h
===================================================================
--- a/glide3x/h3/incsrc/fxhal.h
+++ b/glide3x/h3/incsrc/fxhal.h
@@ -147,9 +147,18 @@ fxHalInitVideoOverlaySurface(
 extern int DRIlock;
 
 // Here are the macro defines for talking to hardware
+#ifdef __alpha__
+extern unsigned char _fxget8(unsigned char *);
+extern unsigned short _fxget16(unsigned short *);
+extern unsigned int _fxget32(unsigned int *);
+	#define GET8(s) _fxget8((unsigned byte *)&s);
+	#define GET16(s) _fxget16((unsigned short *)&s);
+	#define GET(s) _fxget32((unsigned int *)&s);
+#else	
         #define GET8(s) s
         #define GET16(s) s
         #define GET(s) s
+#endif
         #define SET8(d,s) d = s
         #define SET16(d,s) d = s
         #define SET(d,s) d = s
Index: b/glide3x/h3/incsrc/h3defs.h
===================================================================
--- a/glide3x/h3/incsrc/h3defs.h
+++ b/glide3x/h3/incsrc/h3defs.h
@@ -56,11 +56,21 @@
 
 // this crazy macro tests the sign bit of a float by loading it into
 // an integer register and then testing the sign bit of the integer
+#if defined(__LP64__) 
+/* On IA-64, it's faster to do this the obvious way... -davidm 00/08/09 */
+#define FLOAT_ISNEG(f) ((f) < 0.0)
+#else
 #define FLOAT_ISNEG(f) ((*(int *)(&(f))) < 0)
+#endif
 
 // these crazy macros returns the sign of a number (1 if >= 0; -1 if < 0)
+#if defined(__LP64__)
+#define ISIGN(x) ((x) >= 0 ? 1 : -1)
+#define FSIGN(f) ((f) >= 0.0 ? 1 : -1)
+#else
 #define ISIGN(x) (((x) | 0x40000000L) >> 30)
 #define FSIGN(f) ISIGN(*(long *)&f)
+#endif
 
 #define BIT(n)  (1UL<<(n))
 #define SST_MASK(n) (0xFFFFFFFFL >> (32-(n)))
@@ -1257,9 +1267,9 @@
 
 //----------------- useful addressing macros -----------------------
 // return pointer to SST at specified WRAP, CHIP, or TREX
-#define SST_WRAP(sst,n) ((SstRegs *)((n)*0x4000+(FxI32)(sst)))
-#define SST_CHIP(sst,n) ((SstRegs *)((n)*0x400+(FxI32)(sst)))
-#define SST_TMU(sst,n)  ((SstRegs *)((0x800<<(n))+(FxI32)(sst)))
+#define SST_WRAP(sst,n) ((SstRegs *)((n)*0x4000+(AnyPtr)(sst)))
+#define SST_CHIP(sst,n) ((SstRegs *)((n)*0x400+(AnyPtr)(sst)))
+#define SST_TMU(sst,n)  ((SstRegs *)((0x800<<(n))+(AnyPtr)(sst)))
 #define SST_TREX(sst,n) SST_TMU(sst,n)
 
 // offsets from the base of memBaseAddr0
@@ -1304,7 +1314,7 @@
 
 #define SST_IS_REGISTER_ADDR(a)  ( (a) >= SST_IO_OFFSET       && (a) < SST_TEX_OFFSET )
 
-#define SST_BASE_ADDRESS(sst)   ((FxI32)(sst)-SST_3D_OFFSET)
+#define SST_BASE_ADDRESS(sst)   ((AnyPtr)(sst)-SST_3D_OFFSET)
 #define SST_IO_ADDRESS(sst)     (SST_IO_OFFSET+SST_BASE_ADDRESS(sst))
 #define SST_CMDAGP_ADDRESS(sst) (SST_CMDAGP_OFFSET+SST_BASE_ADDRESS(sst))
 #define SST_GUI_ADDRESS(sst)    (SST_2D_OFFSET+SST_BASE_ADDRESS(sst))
Index: b/glide3x/h3/incsrc/h3regs.h
===================================================================
--- a/glide3x/h3/incsrc/h3regs.h
+++ b/glide3x/h3/incsrc/h3regs.h
@@ -208,11 +208,19 @@ typedef volatile struct sstgregs {      
 #ifndef _H2INC
 // STB End changes
 
+#if defined(__alpha__) || defined(__LP64__)
+typedef unsigned int Reg32u;
+typedef int Reg32;
+#else
+typedef unsigned long Reg32u;
+typedef long Reg32;
+#endif
+
 //----------------- SST chip 3D layout -------------------------
 // registers are in groups of 8 for easy decode
 typedef struct vertex_Rec {
-    unsigned long x;            // 12.4 format
-    unsigned long y;            // 12.4
+    Reg32u x;            // 12.4 format
+    Reg32u y;            // 12.4
 } vtxRec;
 
 typedef volatile struct sstregs {       // THE 3D CHIP
@@ -223,118 +231,118 @@ typedef volatile struct sstregs {       
     vtxRec vB;
     vtxRec vC;
 
-    long r;             // 12.12        Parameters
-    long g;             // 12.12
-    long b;             // 12.12
-    long z;             // 20.12
-    long a;             // 12.12
-    long s;             // 14.18
-    long t;             // 14.18
-    long w;             //  2.30
-
-    long drdx;                  // X Gradients
-    long dgdx;
-    long dbdx;
-    long dzdx;
-    long dadx;
-    long dsdx;
-    long dtdx;
-    long dwdx;
-
-    long drdy;                  // Y Gradients
-    long dgdy;
-    long dbdy;
-    long dzdy;
-    long dady;
-    long dsdy;
-    long dtdy;
-    long dwdy;
+    Reg32 r;             // 12.12        Parameters
+    Reg32 g;             // 12.12
+    Reg32 b;             // 12.12
+    Reg32 z;             // 20.12
+    Reg32 a;             // 12.12
+    Reg32 s;             // 14.18
+    Reg32 t;             // 14.18
+    Reg32 w;             //  2.30
+
+    Reg32 drdx;                  // X Gradients
+    Reg32 dgdx;
+    Reg32 dbdx;
+    Reg32 dzdx;
+    Reg32 dadx;
+    Reg32 dsdx;
+    Reg32 dtdx;
+    Reg32 dwdx;
+
+    Reg32 drdy;                  // Y Gradients
+    Reg32 dgdy;
+    Reg32 dbdy;
+    Reg32 dzdy;
+    Reg32 dady;
+    Reg32 dsdy;
+    Reg32 dtdy;
+    Reg32 dwdy;
 
-    unsigned long triangleCMD;  // execute a triangle command (float)
-    unsigned long reservedA;
+    Reg32u triangleCMD;  // execute a triangle command (float)
+    Reg32u reservedA;
     vtxRec FvA;                 // floating point version
     vtxRec FvB;
     vtxRec FvC;
 
-    long Fr;                    // floating point version
-    long Fg;
-    long Fb;
-    long Fz;
-    long Fa;
-    long Fs;
-    long Ft;
-    long Fw;
-
-    long Fdrdx;
-    long Fdgdx;
-    long Fdbdx;
-    long Fdzdx;
-    long Fdadx;
-    long Fdsdx;
-    long Fdtdx;
-    long Fdwdx;
-
-    long Fdrdy;
-    long Fdgdy;
-    long Fdbdy;
-    long Fdzdy;
-    long Fdady;
-    long Fdsdy;
-    long Fdtdy;
-    long Fdwdy;
-
-    unsigned long FtriangleCMD;         // execute a triangle command
-    unsigned long fbzColorPath;         // color select and combine
-    unsigned long fogMode;              // fog Mode
-    unsigned long alphaMode;            // alpha Mode
-    unsigned long fbzMode;              // framebuffer and Z mode
-    unsigned long lfbMode;              // linear framebuffer Mode
-    unsigned long clipLeftRight;        // (6)10(6)10
-    unsigned long clipBottomTop;        // (6)10(6)10
-
-    unsigned long nopCMD;       // execute a nop command
-    unsigned long fastfillCMD;  // execute a fast fill command
-    unsigned long swapbufferCMD;// execute a swapbuffer command
-    unsigned long fogColor;             // (8)888
-    unsigned long zaColor;              // 8(8)16
-    unsigned long chromaKey;            // (8)888
-    unsigned long chromaRange;
-    unsigned long userIntrCmd;
-
-    unsigned long stipple;              // 32 bits, MSB masks pixels
-    unsigned long c0;                   // 8.8.8.8 (ARGB)
-    unsigned long c1;                   // 8.8.8.8 (ARGB)
+    Reg32 Fr;                    // floating point version
+    Reg32 Fg;
+    Reg32 Fb;
+    Reg32 Fz;
+    Reg32 Fa;
+    Reg32 Fs;
+    Reg32 Ft;
+    Reg32 Fw;
+
+    Reg32 Fdrdx;
+    Reg32 Fdgdx;
+    Reg32 Fdbdx;
+    Reg32 Fdzdx;
+    Reg32 Fdadx;
+    Reg32 Fdsdx;
+    Reg32 Fdtdx;
+    Reg32 Fdwdx;
+
+    Reg32 Fdrdy;
+    Reg32 Fdgdy;
+    Reg32 Fdbdy;
+    Reg32 Fdzdy;
+    Reg32 Fdady;
+    Reg32 Fdsdy;
+    Reg32 Fdtdy;
+    Reg32 Fdwdy;
+
+    Reg32u FtriangleCMD;         // execute a triangle command
+    Reg32u fbzColorPath;         // color select and combine
+    Reg32u fogMode;              // fog Mode
+    Reg32u alphaMode;            // alpha Mode
+    Reg32u fbzMode;              // framebuffer and Z mode
+    Reg32u lfbMode;              // linear framebuffer Mode
+    Reg32u clipLeftRight;        // (6)10(6)10
+    Reg32u clipBottomTop;        // (6)10(6)10
+
+    Reg32u nopCMD;       // execute a nop command
+    Reg32u fastfillCMD;  // execute a fast fill command
+    Reg32u swapbufferCMD;// execute a swapbuffer command
+    Reg32u fogColor;             // (8)888
+    Reg32u zaColor;              // 8(8)16
+    Reg32u chromaKey;            // (8)888
+    Reg32u chromaRange;
+    Reg32u userIntrCmd;
+
+    Reg32u stipple;              // 32 bits, MSB masks pixels
+    Reg32u c0;                   // 8.8.8.8 (ARGB)
+    Reg32u c1;                   // 8.8.8.8 (ARGB)
     struct {                            // statistic gathering variables
-        unsigned long fbiPixelsIn;
-        unsigned long fbiChromaFail;
-        unsigned long fbiZfuncFail;
-        unsigned long fbiAfuncFail;
-        unsigned long fbiPixelsOut;
+        Reg32u fbiPixelsIn;
+        Reg32u fbiChromaFail;
+        Reg32u fbiZfuncFail;
+        Reg32u fbiAfuncFail;
+        Reg32u fbiPixelsOut;
     } stats;
 
-    unsigned long fogTable[32];         // 64 entries, 2 per word, 2 bytes each
+    Reg32u fogTable[32];         // 64 entries, 2 per word, 2 bytes each
 
-    unsigned long reservedB[3];
+    Reg32u reservedB[3];
 
-    unsigned long colBufferAddr;
-    unsigned long colBufferStride;
-    unsigned long auxBufferAddr;
-    unsigned long auxBufferStride;
-    unsigned long reservedC;
-
-    unsigned long clipLeftRight1;
-    unsigned long clipBottomTop1;
-    unsigned long reservedD[6];         // NOTE: used to store TMUprivate ptr
+    Reg32u colBufferAddr;
+    Reg32u colBufferStride;
+    Reg32u auxBufferAddr;
+    Reg32u auxBufferStride;
+    Reg32u reservedC;
+
+    Reg32u clipLeftRight1;
+    Reg32u clipBottomTop1;
+    Reg32u reservedD[6];         // NOTE: used to store TMUprivate ptr
                                         
 
-    unsigned long reservedE[8];
+    Reg32u reservedE[8];
 
-    unsigned long reservedF[3];  
-    unsigned long swapBufferPend;
-    unsigned long leftOverlayBuf;
-    unsigned long rightOverlayBuf;
-    unsigned long fbiSwapHistory;
-    unsigned long fbiTrianglesOut;      // triangles out counter
+    Reg32u reservedF[3];  
+    Reg32u swapBufferPend;
+    Reg32u leftOverlayBuf;
+    Reg32u rightOverlayBuf;
+    Reg32u fbiSwapHistory;
+    Reg32u fbiTrianglesOut;      // triangles out counter
 
     FxU32 sSetupMode;
     FxU32 sVx;
@@ -356,27 +364,27 @@ typedef volatile struct sstregs {       
 
     FxU32 sDrawTriCMD;
     FxU32 sBeginTriCMD;
-    unsigned long reservedG[6];
+    Reg32u reservedG[6];
 
-    unsigned long reservedH[8];
+    Reg32u reservedH[8];
 
-    unsigned long reservedI[8];
+    Reg32u reservedI[8];
 
-    unsigned long textureMode;          // texture Mode
-    unsigned long tLOD;                 // texture LOD settings
-    unsigned long tDetail;              // texture detail settings
-    unsigned long texBaseAddr;          // current texture base address
-    unsigned long texBaseAddr1;
-    unsigned long texBaseAddr2;
-    unsigned long texBaseAddr38;
-    unsigned long trexInit0;            // hardware init bits
-    unsigned long trexInit1;            // hardware init bits
+    Reg32u textureMode;          // texture Mode
+    Reg32u tLOD;                 // texture LOD settings
+    Reg32u tDetail;              // texture detail settings
+    Reg32u texBaseAddr;          // current texture base address
+    Reg32u texBaseAddr1;
+    Reg32u texBaseAddr2;
+    Reg32u texBaseAddr38;
+    Reg32u trexInit0;            // hardware init bits
+    Reg32u trexInit1;            // hardware init bits
    
-    unsigned long nccTable0[12];        // NCC decode tables, bits are packed
-    unsigned long nccTable1[12];        // 4 words Y, 4 words I, 4 words Q
+    Reg32u nccTable0[12];        // NCC decode tables, bits are packed
+    Reg32u nccTable1[12];        // 4 words Y, 4 words I, 4 words Q
 
-    unsigned long tChromaKeyMin;
-    unsigned long tChromaKeyMax;
+    Reg32u tChromaKeyMin;
+    Reg32u tChromaKeyMax;
 } SstRegs;
 
 // STB Begin changes
Index: b/glide3x/h3/minihwc/hwcext.h
===================================================================
--- a/glide3x/h3/minihwc/hwcext.h
+++ b/glide3x/h3/minihwc/hwcext.h
@@ -193,7 +193,8 @@ typedef struct hwcExtLinearAddrReq_s {
 /* Returned from HWCEXT_GETLINEARADDR */
 typedef struct hwcExtLinearAddrRes_s {
   FxU32
-    numBaseAddrs,               /* # base addresses */
+    numBaseAddrs;               /* # base addresses */
+  AnyPtr
     baseAddresses[HWCEXT_MAX_BASEADDR]; /* linear Addresses  */
 } hwcExtLinearAddrRes_t;
 
Index: b/glide3x/h3/minihwc/hwcio.h
===================================================================
--- a/glide3x/h3/minihwc/hwcio.h
+++ b/glide3x/h3/minihwc/hwcio.h
@@ -41,46 +41,57 @@ extern char *cmdAGPRegNames[];
 extern char *waxRegNames[];
 extern char *sstRegNames[];
 
+#ifdef __alpha__
+extern unsigned int _fxget32(unsigned int *);
+#define GET(s) _fxget32((unsigned int *)&s);
+#define SET(d,s) d = s
+#endif
+
+#ifndef GET
+#define GET(s) s
+#define SET(d,s) d = s
+#endif
+
 /*
 **  I/O Macros
 */
 #define HWC_IO_STORE(regInfo, reg, val)\
 GDBG_INFO(120, "Storing 0x%x to IO Register %s\n", val,\
   ioRegNames[(offsetof(SstIORegs, reg)) >> 2]);\
-((SstIORegs *) regInfo.ioMemBase)->reg = val
+SET(((SstIORegs *) regInfo.ioMemBase)->reg,val)
 
 #define HWC_IO_LOAD(regInfo, reg, val)\
-val = ((SstIORegs *) regInfo.ioMemBase)->reg;\
+val = GET(((SstIORegs *) regInfo.ioMemBase)->reg);\
 GDBG_INFO(120, "Loaded 0x%x from IO Register %s\n", val,\
   ioRegNames[(offsetof(SstIORegs, reg)) >> 2]);
 
 #define HWC_CAGP_STORE(regInfo, reg, val)\
 GDBG_INFO(120, "Storing 0x%x to CAGP Register %s\n", val,\
   cmdAGPRegNames[(offsetof(SstCRegs, reg)) >> 2]);\
-((SstCRegs *) (regInfo.cmdAGPBase))->reg = val
+SET(((SstCRegs *) (regInfo.cmdAGPBase))->reg,val)
 
 #define HWC_CAGP_LOAD(regInfo, reg, val)\
-val = ((SstCRegs *) (regInfo).cmdAGPBase)->reg;\
+val = GET(((SstCRegs *) (regInfo).cmdAGPBase)->reg);\
 GDBG_INFO(120, "Loaded 0x%x from CAGP Register %s\n", val,\
   cmdAGPRegNames[(offsetof(SstCRegs, reg)) >> 2]);
   
 #define HWC_WAX_STORE(regInfo, reg, val)\
 GDBG_INFO(120, "Storing 0x%x to WAX Register %s\n", val,\
   waxRegnames[(offsetof(SstGRegs, reg)) >> 2]);\
-((SstGRegs *) regInfo.waxBase)->reg = val
+SET(((SstGRegs *) regInfo.waxBase)->reg,val)
 
 #define HWC_WAX_LOAD(regInfo, reg, val)\
-val = ((SstGRegs *) regInfo.waxBase)->reg;\
+val = GET(((SstGRegs *) regInfo.waxBase)->reg);\
 GDBG_INFO(120, "Loaded 0x%x from WAX Register %s\n", val,\
   waxRegnames[(offsetof(SstGRegs, reg)) >> 2]);
 
 #define HWC_SST_STORE(regInfo, reg, val)\
 GDBG_INFO(120, "Storing 0x%x to 3D Register %s\n", val,\
  sstRegNames[(offsetof(SstRegs, reg)) >> 2]);\
-((SstRegs *) regInfo.sstBase)->reg = val
+SET(((SstRegs *) regInfo.sstBase)->reg,val)
 
 #define HWC_SST_LOAD(regInfo, reg, val)\
-val = ((SstRegs *) regInfo.sstBase)->reg;\
+val = GET(((SstRegs *) regInfo.sstBase)->reg);\
 GDBG_INFO(120, "Loaded 0x%x from WAX Register %s\n", val,\
  sstRegNames[(offsetof(SstRegs, reg)) >> 2]);
 
Index: b/glide3x/h3/minihwc/linhwc.c.dri
===================================================================
--- a/glide3x/h3/minihwc/linhwc.c.dri
+++ b/glide3x/h3/minihwc/linhwc.c.dri
@@ -67,7 +67,15 @@ hwcCheckMemSize(hwcBoardInfo *bInfo, FxU
 #include "lindri.h"
 
 static FxU32 fenceVar;
+#if defined(__ia64__)
+#define P6FENCE asm volatile("mf.a" ::: "memory");
+#elif defined(__alpha__)
+#define P6FENCE asm volatile("mb" ::: "memory");
+#elif defined(__i386__)
 #define P6FENCE asm("xchg %%eax, %0" : : "m" (fenceVar) : "eax");
+#else
+#error Need to Define P6FENCE for this architecture
+#endif
 
 #define MAXFIFOSIZE     0x40000
 #define FIFOPAD         0x0000
@@ -142,7 +150,7 @@ static void loadEnvFile() {
   char data[128];
   char *env, *val;
   envitem *item;
-  int first=1;
+  int is_first=1;
 
   if (envinit) return;
   envinit=1;
@@ -154,9 +162,9 @@ static void loadEnvFile() {
     if (*data=='\n') continue;
     val=strchr(data, '=');
     if (!val) {
-      if (first) {
+      if (is_first) {
 	fprintf(stderr, "In config file /etc/conf.3dfx/voodoo3:\n");
-	first=0;
+	is_first=0;
       }
       fprintf(stderr, "Malformed line: %s\n", data);
       continue;
@@ -229,8 +237,8 @@ hwcMapBoard(hwcBoardInfo *bInfo, FxU32 b
   }
 
   bInfo->linearInfo.initialized = FXTRUE;
-  bInfo->linearInfo.linearAddress[0]=(FxU32)driInfo.pRegs;
-  bInfo->linearInfo.linearAddress[1]=(FxU32)driInfo.pFB;
+  bInfo->linearInfo.linearAddress[0]=(AnyPtr)driInfo.pRegs;
+  bInfo->linearInfo.linearAddress[1]=(AnyPtr)driInfo.pFB;
   return FXTRUE;
 }
 
@@ -829,7 +837,11 @@ hwcResolutionSupported(hwcBoardInfo *bIn
 #undef FN_NAME
 } /* hwcResolutionSupported */
 
-void grDRIImportFifo(int fifoPtr, int fifoRead)
+extern void _grDRIImportFifo(FxU32 fifoPtr, FxU32 fifoRead);
+extern void _grDRIInvalidateAll(void);
+extern void _grDRIExportFifo(FxU32 *fifoPtr, FxU32 *fifoRead);
+
+void grDRIImportFifo(FxU32 fifoPtr, FxU32 fifoRead)
 {
   _grImportFifo(fifoPtr, fifoRead);
 }
@@ -840,5 +852,5 @@ void grDRIInvalidateAll() {
 
 void grDRIResetSAREA()
 {
-  _grExportFifo(driInfo.fifoPtr, driInfo.fifoRead);
+  _grExportFifo((FxU32*)driInfo.fifoPtr, (FxU32*)driInfo.fifoRead);
 }
Index: b/glide3x/h3/minihwc/minihwc.c
===================================================================
--- a/glide3x/h3/minihwc/minihwc.c
+++ b/glide3x/h3/minihwc/minihwc.c
@@ -1078,7 +1078,7 @@ hwcMapBoard(hwcBoardInfo *bInfo, FxU32 b
     for (bAddr = 0; bAddr < 2; bAddr++) {
       if ((bAddrMask & (0x01UL << bAddr)) != 0x00UL) {
         bInfo->linearInfo.linearAddress[bAddr] = 
-          (FxU32)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
+          (AnyPtr)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
                                  0x1000000, &bInfo->deviceNum, bInfo->boardNum, bAddr);
       }
     }
@@ -1087,13 +1087,13 @@ hwcMapBoard(hwcBoardInfo *bInfo, FxU32 b
      * unconditionally
      */
     bInfo->linearInfo.linearAddress[2] = 
-      (FxU32)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
+      (AnyPtr)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
                              0x1000000, &bInfo->deviceNum, bInfo->boardNum, 2);
 
     /* Does the caller want the rom bios? */
     if ((bAddrMask & 0x08UL) != 0x00UL) {
       bInfo->linearInfo.linearAddress[3] = 
-        (FxU32)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
+        (AnyPtr)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
                                0x1000000, &bInfo->deviceNum, bInfo->boardNum, 3);
     }
   }
Index: b/glide3x/h3/minihwc/minihwc.h
===================================================================
--- a/glide3x/h3/minihwc/minihwc.h
+++ b/glide3x/h3/minihwc/minihwc.h
@@ -238,14 +238,14 @@ typedef struct hwcPCIInfo_s {
 typedef struct hwcLinearInfo_s {
   FxBool
     initialized;
-  FxU32
+  AnyPtr
     linearAddress[HWC_NUM_BASE_ADDR];
 } hwcLinearInfo;
 
 typedef struct hwcRegInfo_s {
   FxBool
     initialized;
-  volatile FxU32
+  volatile AnyPtr
     ioMemBase,                  /* mem base for I/O aliases */
     cmdAGPBase,                 /* CMD/AGP register base */
     waxBase,                    /* 2D register base */
@@ -253,7 +253,7 @@ typedef struct hwcRegInfo_s {
     lfbBase,                    /* 3D lfb base */
     rawLfbBase;                 /* Raw LFB base (base address 1) */
 #if __POWERPC__
-  ioPortBase;                   /* PPC does I/O via a 32-bit address */
+  FxU32 ioPortBase;                   /* PPC does I/O via a 32-bit address */
 #else       
   volatile FxU16
     ioPortBase,                 /* I/O base address */
Index: b/glide3x/h5/glide3/src/cpu_alpha.c
===================================================================
--- /dev/null
+++ b/glide3x/h5/glide3/src/cpu_alpha.c
@@ -0,0 +1,21 @@
+#ifdef __alpha__
+
+#include <stdio.h>
+#include <string.h>
+
+#include <3dfx.h>
+#include <glidesys.h>
+
+#define FX_DLL_DEFINITION
+#include <fxdll.h>
+#include <glide.h>
+#include "fxglide.h"
+
+#define	NOT_PENTIUM	4 /* see cpudetect.S */
+
+extern FxI32 GR_CDECL
+_cpu_detect_asm(void)
+{
+    return(NOT_PENTIUM);
+}
+#endif
Index: b/glide3x/h5/glide3/src/cpudtect.s
===================================================================
--- a/glide3x/h5/glide3/src/cpudtect.s
+++ b/glide3x/h5/glide3/src/cpudtect.s
@@ -58,6 +58,20 @@
 /*  2     3/04/97 9:10p Dow */
 
 
+#ifdef __ia64__
+
+	.align 32
+	.global _cpu_detect_asm
+	.proc _cpu_detect_asm
+
+_cpu_detect_asm:
+	mov ret0=0
+	br.ret.sptk.few b0
+
+	.end _cpu_detect_asm
+
+#else /* !__ia64__ */
+
 
 .file "cpudtect.asm"
 
@@ -333,3 +347,4 @@ double_precision_asm:
 .size double_precision_asm,.L_END_double_precision_asm-double_precision_asm
 
 .end
+#endif
Index: b/glide3x/h5/glide3/src/diget.c
===================================================================
--- a/glide3x/h5/glide3/src/diget.c
+++ b/glide3x/h5/glide3/src/diget.c
@@ -807,11 +807,11 @@ GR_DIENTRY(grGet, FxU32, (FxU32 pname, F
     break;
 
   case GR_SURFACE_TEXTURE:
-    if (plength == 4) {
+    if (plength == sizeof(long)) {
       GR_DCL_GC;
 
 #ifdef GLIDE_INIT_HWC
-      *params = (FxU32) &gc->tBuffer;
+      *params = (AnyPtr) &gc->tBuffer;
       retVal = plength;
 #endif
     }
Index: b/glide3x/h5/glide3/src/disst.c
===================================================================
--- a/glide3x/h5/glide3/src/disst.c
+++ b/glide3x/h5/glide3/src/disst.c
@@ -184,7 +184,7 @@ GR_DIENTRY(grSstSelect, void, ( int whic
     GrErrorCallback( "grSstSelect:  non-existent SST", FXTRUE );
 
   _GlideRoot.current_sst = which;
-  setThreadValue( (FxU32)&_GlideRoot.GCs[_GlideRoot.current_sst] );
+  setThreadValue( (AnyPtr)&_GlideRoot.GCs[_GlideRoot.current_sst] );
 
 #ifdef GLIDE_MULTIPLATFORM
   _GlideRoot.curGCFuncs = _GlideRoot.curGC->gcFuncs;
Index: b/glide3x/h5/glide3/src/distrip.c
===================================================================
--- a/glide3x/h5/glide3/src/distrip.c
+++ b/glide3x/h5/glide3/src/distrip.c
@@ -497,7 +497,7 @@ GR_DIENTRY(grDrawVertexArrayContiguous, 
     FxU32 i;
     for (i = 0; i < Count; i++)
       GDBG_INFO(110, "%s:  pointers[%d] = 0x%x\n",
-                FN_NAME, i, (int)pointers + gc->state.vData.vStride * i);
+                FN_NAME, i, (long)pointers + gc->state.vData.vStride * i);
   }
 #endif
 
@@ -552,10 +552,10 @@ GR_DIENTRY(grDrawVertexArrayContiguous, 
     else {
       void *b_ptr, *c_ptr;
       while ((int)Count >= 3) {
-        b_ptr = (void *)((FxU32)pointers + stride);
-        c_ptr = (void *)((FxU32)pointers + stride*2);
+        b_ptr = (void *)((AnyPtr)pointers + stride);
+        c_ptr = (void *)((AnyPtr)pointers + stride*2);
         TRISETUP(pointers, b_ptr, c_ptr);
-        pointers = (void *)((FxU32)c_ptr + stride);
+        pointers = (void *)((AnyPtr)c_ptr + stride);
         Count -= 3;
       }
     }
Index: b/glide3x/h5/glide3/src/fifo.c
===================================================================
--- a/glide3x/h5/glide3/src/fifo.c
+++ b/glide3x/h5/glide3/src/fifo.c
@@ -502,7 +502,7 @@ static const char * h3SstIORegNames[] = 
 } ;
 
 
-#define GEN_INDEX(a) ((((FxU32) a) - ((FxU32) gc->reg_ptr)) >> 2)
+#define GEN_INDEX(a) ((((AnyPtr) a) - ((AnyPtr) gc->reg_ptr)) >> 2)
 
 void
 _grFifoWriteDebug(FxU32 addr, FxU32 val, FxU32 fifoPtr)
@@ -733,7 +733,7 @@ _FifoFlush( void ) 
 #undef FN_NAME
 } /* _FifoFlush */
 
-FxU32 _grHwFifoPtrSlave(FxU32 slave, FxBool ignored);
+AnyPtr _grHwFifoPtrSlave(FxU32 slave, FxBool ignored);
 
 void FX_CALL
 _grCommandTransportMakeRoom(const FxI32 blockSize, const char* fName, const int fLine)
@@ -757,9 +757,9 @@ _grCommandTransportMakeRoom(const FxI32 
     /* Update to the currently writing command buffer */
     fifo.cmdBuf.baseAddr += cmdBufferOffset;
     fifo.cmdBuf.hwOffset += cmdBufferOffset;
-    fifo.cmdBuf.size      = ((FxU32)gcFifo->fifoPtr - fifo.cmdBuf.baseAddr);
+    fifo.cmdBuf.size      = ((AnyPtr)gcFifo->fifoPtr - fifo.cmdBuf.baseAddr);
     
-    fifo.stateBuf.baseAddr  = (FxU32)gcFifo->stateBuffer;
+    fifo.stateBuf.baseAddr  = (AnyPtr)gcFifo->stateBuffer;
     fifo.stateBuf.hwOffset += (gcFifo->hwcFifoInfo.stateBuf.allocUnit * gcFifo->curCommandBuf);
     fifo.stateBuf.size      = sizeof(GrStateBuffer);
     
@@ -805,7 +805,7 @@ _grCommandTransportMakeRoom(const FxI32 
           gcFifo->curCommandBuf = nextBufferIndex;
         
         /* Set the current fifo ptr in allocation blocks */
-        gcFifo->fifoPtr = (FxU32*)(gcFifo->hwcFifoInfo.cmdBuf.baseAddr +
+        gcFifo->fifoPtr = (AnyPtr*)(gcFifo->hwcFifoInfo.cmdBuf.baseAddr +
                                    (gcFifo->hwcFifoInfo.cmdBuf.allocUnit * gcFifo->curCommandBuf));
         
         /* Set the state buffer to be the 'next' one in the ready
@@ -882,7 +882,7 @@ _grCommandTransportMakeRoom(const FxI32 
     gc->contextP = 1; /* always has context in CSIM */
 #endif /* defined(GLIDE_INIT_HWC) && !defined(__linux__) */
     if (gc->contextP) {
-      FxU32 wrapAddr = 0x00UL;
+      AnyPtr wrapAddr = 0x00UL;
       FxU32 checks;
 
       GR_ASSERT(blockSize > 0);
@@ -920,12 +920,12 @@ _grCommandTransportMakeRoom(const FxI32 
                        "\tfifoRoom: (0x%X : 0x%X) : (0x%X : 0x%X)\n"
                        "\tfifo hw: (0x%X : 0x%X)\n",
                        ((fName == NULL) ? "Unknown" : fName), fLine,
-                       (((FxU32)gc->cmdTransportInfo.fifoPtr - (FxU32)gc->cmdTransportInfo.fifoStart) + 
+                       (((AnyPtr)gc->cmdTransportInfo.fifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoStart) + 
                         (FxU32)gc->cmdTransportInfo.fifoOffset),
                        blockSize,
                        gc->cmdTransportInfo.roomToReadPtr, gc->cmdTransportInfo.roomToEnd, 
                        gc->cmdTransportInfo.fifoRoom, writes,
-                       HW_FIFO_PTR(FXTRUE) - (FxU32)gc->rawLfb, gc->cmdTransportInfo.fifoRead);
+                       HW_FIFO_PTR(FXTRUE) - (AnyPtr)gc->rawLfb, gc->cmdTransportInfo.fifoRead);
         
 #endif /* GDBG_INFO_ON */
         
@@ -943,25 +943,25 @@ _grCommandTransportMakeRoom(const FxI32 
   again:
       /* do we need to stall? */
       {
-        FxU32 lastHwRead = gc->cmdTransportInfo.fifoRead;
+        AnyPtr lastHwRead = gc->cmdTransportInfo.fifoRead;
         FxI32 roomToReadPtr = gc->cmdTransportInfo.roomToReadPtr;
         
         while (roomToReadPtr < blockSize) {
-          FxU32 curReadPtr = HW_FIFO_PTR(FXTRUE);
-          FxU32 curReadDist = curReadPtr - lastHwRead;
+          AnyPtr curReadPtr = HW_FIFO_PTR(FXTRUE);
+          FxI32 curReadDist = curReadPtr - lastHwRead;
 
           /* Handle slave chips.  This code lifted from cvg and modified
            * to deal with multiple slave chips. */
           if(gc->chipCount > 1) {
             FxU32 slave;
             for(slave = 1; slave < gc->chipCount; slave++) {              
-              const FxU32 slaveReadPtr = _grHwFifoPtrSlave(slave, 0);
+              const AnyPtr slaveReadPtr = _grHwFifoPtrSlave(slave, 0);
               const FxU32 slaveReadDist = (slaveReadPtr - lastHwRead);
               FxI32 distSlave = (FxI32)slaveReadDist;
               FxI32 distMaster = (FxI32)curReadDist;
 
-              GR_ASSERT((slaveReadPtr >= (FxU32)gc->cmdTransportInfo.fifoStart) &&
-                        (slaveReadPtr < (FxU32)gc->cmdTransportInfo.fifoEnd));
+              GR_ASSERT((slaveReadPtr >= (AnyPtr)gc->cmdTransportInfo.fifoStart) &&
+                        (slaveReadPtr < (AnyPtr)gc->cmdTransportInfo.fifoEnd));
           
               /* Get the actual absolute distance to the respective fifo ptrs */
               if (distSlave < 0) distSlave += (FxI32)gc->cmdTransportInfo.fifoSize - FIFO_END_ADJUST;
@@ -1037,8 +1037,8 @@ _grCommandTransportMakeRoom(const FxI32 
             checks = 0;
           }
 #endif /* GLIDE_DEBUG */
-          GR_ASSERT((curReadPtr >= (FxU32)gc->cmdTransportInfo.fifoStart) &&
-                    (curReadPtr < (FxU32)gc->cmdTransportInfo.fifoEnd));
+          GR_ASSERT((curReadPtr >= (AnyPtr)gc->cmdTransportInfo.fifoStart) &&
+                    (curReadPtr < (AnyPtr)gc->cmdTransportInfo.fifoEnd));
               
           roomToReadPtr += curReadDist;
               
@@ -1050,8 +1050,8 @@ _grCommandTransportMakeRoom(const FxI32 
           lastHwRead = curReadPtr;
         }
           
-        GR_ASSERT((lastHwRead >= (FxU32)gc->cmdTransportInfo.fifoStart) &&
-                  (lastHwRead < (FxU32)gc->cmdTransportInfo.fifoEnd));
+        GR_ASSERT((lastHwRead >= (AnyPtr)gc->cmdTransportInfo.fifoStart) &&
+                  (lastHwRead < (AnyPtr)gc->cmdTransportInfo.fifoEnd));
           
         /* Update cached copies */
         gc->cmdTransportInfo.fifoRead = lastHwRead;
@@ -1098,7 +1098,7 @@ _grCommandTransportMakeRoom(const FxI32 
           
         P6FENCE;
     
-        wrapAddr = (FxU32)gc->cmdTransportInfo.fifoPtr;
+        wrapAddr = (AnyPtr)gc->cmdTransportInfo.fifoPtr;
           
         /* Update roomXXX fields for the actual wrap */
         gc->cmdTransportInfo.roomToReadPtr -= gc->cmdTransportInfo.roomToEnd;
@@ -1131,12 +1131,12 @@ _grCommandTransportMakeRoom(const FxI32 
                 "\tfifoBlock: (0x%X : 0x%X)\n"
                 "\tfifoRoom: (0x%X : 0x%X : 0x%X)\n"
                 "\tfifo hw: (0x%X : 0x%X) : (0x%X : 0x%X : 0x%X)\n",
-                (((FxU32)gc->cmdTransportInfo.fifoPtr - (FxU32)gc->cmdTransportInfo.fifoStart) + 
+                (((AnyPtr)gc->cmdTransportInfo.fifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoStart) + 
                  (FxU32)gc->cmdTransportInfo.fifoOffset),
                 blockSize,
                 gc->cmdTransportInfo.roomToReadPtr, 
                 gc->cmdTransportInfo.roomToEnd, gc->cmdTransportInfo.fifoRoom,
-                HW_FIFO_PTR(FXTRUE) - (FxU32)gc->rawLfb, gc->cmdTransportInfo.fifoRead, 
+                HW_FIFO_PTR(FXTRUE) - (AnyPtr)gc->rawLfb, gc->cmdTransportInfo.fifoRead, 
                 GR_CAGP_GET(depth), GR_CAGP_GET(holeCount), GR_GET(hw->status));
       
       FIFO_ASSERT();
@@ -1176,10 +1176,10 @@ _grH3FifoDump_Linear(const FxU32* const 
 }
 
 
-FxU32
+AnyPtr
 _grHwFifoPtr(FxBool ignored)
 {
-  FxU32 rVal = 0;
+  AnyPtr rVal = 0;
 
   FxU32 status, readPtrL1, readPtrL2;
   FxU32 chip ; /* AJB SLI MAYHEM */
@@ -1238,7 +1238,7 @@ _grHwFifoPtr(FxBool ignored)
         readPtrL2 = GET(gc->cRegs->cmdFifo0.readPtrL);
       } while (readPtrL1 != readPtrL2);
     }
-    rVal = (((FxU32)gc->cmdTransportInfo.fifoStart) + 
+    rVal = (((AnyPtr)gc->cmdTransportInfo.fifoStart) + 
             readPtrL2 - 
             (FxU32)gc->cmdTransportInfo.fifoOffset);
   }
@@ -1246,10 +1246,10 @@ _grHwFifoPtr(FxBool ignored)
 } /* _grHwFifoPtr */
 
 
-FxU32
+AnyPtr
 _grHwFifoPtrSlave(FxU32 slave, FxBool ignored)
 {
-  FxU32 rVal = 0;
+  AnyPtr rVal = 0;
 
   FxU32 status, readPtrL1, readPtrL2;
   GR_DCL_GC;
@@ -1264,7 +1264,7 @@ _grHwFifoPtrSlave(FxU32 slave, FxBool ig
     readPtrL2 = GET(gc->slaveCRegs[slave-1]->cmdFifo0.readPtrL);
   } while (readPtrL1 != readPtrL2);
 
-  rVal = (((FxU32)gc->cmdTransportInfo.fifoStart) + 
+  rVal = (((AnyPtr)gc->cmdTransportInfo.fifoStart) + 
           readPtrL2 - 
           (FxU32)gc->cmdTransportInfo.fifoOffset);
   
@@ -1368,8 +1368,23 @@ _reg_group_begin_internal_wax( FxU32 __r
 
 #ifdef __linux__
 
+#ifdef __alpha__
+unsigned char _fxget8( unsigned char *pval ) {
+    __asm__ __volatile__("mb": : :"memory");
+    return( *pval );
+}
+unsigned short _fxget16( unsigned short *pval ) {
+    __asm__ __volatile__("mb": : :"memory");
+    return( *pval );
+}
+unsigned int _fxget32( unsigned int *pval ) {
+    __asm__ __volatile__("mb": : :"memory");
+    return( *pval );
+}
+#endif /* __alpha__ */
+
 void
-_grImportFifo(int fifoPtr, int fifoRead) {
+_grImportFifo(AnyPtr fifoPtr, AnyPtr fifoRead) {
   struct cmdTransportInfo* gcFifo;
   FxU32 readPos;
   GR_DCL_GC;
@@ -1388,13 +1403,13 @@ _grImportFifo(int fifoPtr, int fifoRead)
   gcFifo=&gc->cmdTransportInfo;
   readPos=readPos-gcFifo->fifoOffset;
   gcFifo->fifoPtr = gcFifo->fifoStart + (readPos>>2);
-  gcFifo->fifoRead = (FxU32)gcFifo->fifoPtr;
+  gcFifo->fifoRead = (AnyPtr)gcFifo->fifoPtr;
 #else
   gcFifo=&gc->cmdTransportInfo;
   gcFifo->fifoPtr = gc->rawLfb+(fifoPtr>>2);
   gcFifo->fifoRead = ((int)gc->rawLfb)+fifoRead;
 #endif
-  gcFifo->roomToReadPtr = gcFifo->fifoRead-((int)gcFifo->fifoPtr)-FIFO_END_ADJUST-sizeof(FxU32);
+  gcFifo->roomToReadPtr = gcFifo->fifoRead-((AnyPtr)gcFifo->fifoPtr)-FIFO_END_ADJUST-sizeof(FxU32);
   if (gcFifo->roomToReadPtr<0) gcFifo->roomToReadPtr+=gcFifo->fifoSize;
   gcFifo->roomToEnd = gcFifo->fifoSize - 
     ((gcFifo->fifoPtr-gcFifo->fifoStart)<<2) -
@@ -1407,12 +1422,12 @@ _grImportFifo(int fifoPtr, int fifoRead)
 }
 
 void
-_grExportFifo(int *fifoPtr, int *fifoRead) {
+_grExportFifo(FxU32 *fifoPtr, FxU32 *fifoRead) {
   struct cmdTransportInfo* gcFifo;
   GR_DCL_GC;
   gcFifo=&gc->cmdTransportInfo;
   *fifoPtr=(gcFifo->fifoPtr-gc->rawLfb)<<2;
-  *fifoRead=(gcFifo->fifoRead-(int)gc->rawLfb);
+  *fifoRead=(gcFifo->fifoRead-(AnyPtr)gc->rawLfb);
 }
 
 int
Index: b/glide3x/h5/glide3/src/fxcmd.h
===================================================================
--- a/glide3x/h5/glide3/src/fxcmd.h
+++ b/glide3x/h5/glide3/src/fxcmd.h
@@ -188,6 +188,12 @@ extern FxU32
 _grGet32(volatile FxU32* const sstAddr);
 #endif /* USE_PACKET_FIFO */
 
+#ifdef __linux__
+void _grImportFifo(AnyPtr fifoPtr, AnyPtr fifoRead);
+void _grExportFifo(FxU32 *fifoPtr, FxU32 *fifoRead);
+void _grInvalidateAll(void);
+#endif
+
 #if !USE_PACKET_FIFO
 /* NOTE: fifoFree is the number of entries, each is 8 bytes */
 #define GR_CHECK_FOR_ROOM(n,p) \
@@ -222,7 +228,7 @@ do { \
 /* NB: This should be used sparingly because it does a 'real' hw read
  * which is *SLOW*.
  */
-FxU32 _grHwFifoPtr(FxBool);
+AnyPtr _grHwFifoPtr(FxBool);
 #define HW_FIFO_PTR(a) _grHwFifoPtr(a)
 
 #if FIFO_ASSERT_FULL
@@ -233,7 +239,7 @@ FxU32 _grHwFifoPtr(FxBool);
 #else /* !FIFO_ASSERT_FULL */
 #define FIFO_ASSERT() \
 ASSERT_FAULT_IMMED((FxU32)gc->cmdTransportInfo.fifoRoom < gc->cmdTransportInfo.fifoSize); \
-ASSERT_FAULT_IMMED((FxU32)gc->cmdTransportInfo.fifoPtr < (FxU32)gc->cmdTransportInfo.fifoEnd)
+ASSERT_FAULT_IMMED((AnyPtr)gc->cmdTransportInfo.fifoPtr < (AnyPtr)gc->cmdTransportInfo.fifoEnd)
 #endif /* !FIFO_ASSERT_FULL */
 
 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
@@ -296,7 +302,7 @@ do {\
 #define GR_CHECK_FOR_ROOM(__n, __p) \
 do { \
   const FxU32 writeSize = (__n) + ((__p) * sizeof(FxU32));            /* Adjust for size of hdrs */ \
-  ASSERT(((FxU32)(gc->cmdTransportInfo.fifoPtr) & FIFO_ALIGN_MASK) == 0); /* alignment */ \
+  ASSERT(((AnyPtr)(gc->cmdTransportInfo.fifoPtr) & FIFO_ALIGN_MASK) == 0); /* alignment */ \
   ASSERT(writeSize < gc->cmdTransportInfo.fifoSize - sizeof(FxU32)); \
   FIFO_ASSERT(); \
   if (gc->cmdTransportInfo.fifoRoom < (FxI32)writeSize) { \
@@ -325,7 +331,7 @@ if (gc->cmdTransportInfo.autoBump) {\
 }
 
 #define GR_SET_FIFO_PTR(__n, __p) \
-  gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr; \
+  gc->checkPtr = (AnyPtr)gc->cmdTransportInfo.fifoPtr; \
   gc->checkCounter = ((__n) + ((__p) << 2))
 #else
 #define GR_CHECK_FIFO_PTR() 
@@ -337,7 +343,7 @@ if (gc->cmdTransportInfo.autoBump) {\
                   GDBG_ERROR("GR_ASSERT_SIZE","byte counter should be %d but is %d\n", \
                               gc->expected_counter,gc->counter); \
                 GR_CHECK_FIFO_PTR(); \
-                gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr; \
+                gc->checkPtr = (AnyPtr)gc->cmdTransportInfo.fifoPtr; \
                 gc->checkCounter = 0; \
                 ASSERT(gc->counter == gc->expected_counter); \
                 gc->counter = gc->expected_counter = 0
@@ -373,12 +379,17 @@ if (gc->cmdTransportInfo.autoBump) {\
 
 #if USE_PACKET_FIFO
 #if GLIDE_DEBUG
+#if defined(__alpha__) || defined(__LP64__)
+#define DEBUGFIFOWRITE(a,b,c)
+#define DEBUGFIFOFWRITE(a,b,c)
+#else
 void _grFifoWriteDebug(FxU32 addr, FxU32 val, FxU32 fifoPtr);
 #define DEBUGFIFOWRITE(a,b,c) \
 _grFifoWriteDebug((FxU32) a, (FxU32) b, (FxU32) c)
 void _grFifoFWriteDebug(FxU32 addr, float val, FxU32 fifoPtr);
 #define DEBUGFIFOFWRITE(a,b,c) \
 _grFifoFWriteDebug((FxU32) a, (float) b, (FxU32) c)
+#endif
 
 extern void _reg_group_begin_internal_wax( FxU32 regBase,
                                            FxU32 groupNum,             
@@ -758,7 +769,7 @@ do {                                    
     GDBG_INFO(120, "REG_GROUP_SET:\n");                                  \
   }                                                                      \
   GDBG_INFO(120, "\tFile: %s Line %d\n", __FILE__, __LINE__);            \
-  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (FxU32) _regGroupFifoPtr - (FxU32)gc->rawLfb, __val);\
+  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (AnyPtr) _regGroupFifoPtr - (AnyPtr)gc->rawLfb, __val);\
   SET_FIFO(*_regGroupFifoPtr++, (__val)); \
   GR_INC_SIZE(sizeof(FxU32)); \
 } while(0)
@@ -779,7 +790,7 @@ do {                                    
     GDBG_INFO(120, "REG_GROUP_SET:\n");                                  \
   }                                                                      \
   GDBG_INFO(120, "\tFile: %s Line %d\n", __FILE__, __LINE__);            \
-  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (FxU32) _regGroupFifoPtr - (FxU32)gc->rawLfb, __val);\
+  GDBG_INFO(120, "\tfifoPtr: 0x%x, Val: 0x%x\n", (AnyPtr) _regGroupFifoPtr - (AnyPtr)gc->rawLfb, __val);\
   SET_FIFO(*_regGroupFifoPtr++, (__val)); \
   GR_INC_SIZE(sizeof(FxU32)); \
 } while(0)
@@ -795,7 +806,7 @@ do { \
   }                                                                      \
   GDBG_INFO(220, "REG_GROUP_SET_WAX:\n");\
   GDBG_INFO(220, "\tFile: %s Line %d\n", __FILE__, __LINE__);\
-  GDBG_INFO(220, "\tfifoPtr: 0x%x, Val: 0x%x\n", (FxU32) _regGroupFifoPtr - (FxU32)gc->rawLfb, __val);\
+  GDBG_INFO(220, "\tfifoPtr: 0x%x, Val: 0x%x\n", (AnyPtr) _regGroupFifoPtr - (AnyPtr)gc->rawLfb, __val);\
   SET_FIFO(*_regGroupFifoPtr++, (__val)); \
   GR_INC_SIZE(sizeof(FxU32)); \
 } while(0)
@@ -825,8 +836,8 @@ do { \
 
 #define REG_GROUP_END() \
   ASSERT(_checkP); \
-  ASSERT((((FxU32)_regGroupFifoPtr - (FxU32)gc->cmdTransportInfo.fifoPtr) >> 2) == _groupNum + 1); \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)_regGroupFifoPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  ASSERT((((AnyPtr)_regGroupFifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr) >> 2) == _groupNum + 1); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)_regGroupFifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = (FxU32*)_regGroupFifoPtr; \
   GDBG_INFO(gc->myLevel + 200, "\tGroupEnd: (0x%X : 0x%X)\n", \
             gc->cmdTransportInfo.fifoPtr, gc->cmdTransportInfo.fifoRoom); \
@@ -839,7 +850,7 @@ do { \
   if (gc->contextP) { \
     FxU32* curFifoPtr = gc->cmdTransportInfo.fifoPtr; \
     FXUNUSED(__base); \
-    GR_ASSERT(((FxU32)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
+    GR_ASSERT(((AnyPtr)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
     GR_CHECK_COMPATABILITY(FN_NAME, \
                            !gc->open, \
                            "Called before grSstWinOpen()"); \
@@ -882,7 +893,7 @@ do { \
   if (gc->contextP) { \
     FxU32* curFifoPtr = gc->cmdTransportInfo.fifoPtr; \
     FXUNUSED(__base); \
-    GR_ASSERT(((FxU32)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
+    GR_ASSERT(((AnyPtr)(curFifoPtr) & FIFO_ALIGN_MASK) == 0);    /* alignment */ \
     GR_CHECK_COMPATABILITY(FN_NAME, \
                            !gc->open, \
                            "Called before grSstWinOpen()"); \
@@ -1038,10 +1049,10 @@ _grH3FifoDump_Linear(const FxU32* const 
   GR_CHECK_COMPATABILITY(FN_NAME, \
                          !gc->open, \
                          "Called before grSstWinOpen()"); \
-  GR_ASSERT(((FxU32)(tPackPtr) & FIFO_ALIGN_MASK) == 0);   /* alignment */ \
+  GR_ASSERT(((AnyPtr)(tPackPtr) & FIFO_ALIGN_MASK) == 0);   /* alignment */ \
   GR_ASSERT((((__nVerts) * (__vertSize)) + sizeof(FxU32)) <= (FxU32)gc->cmdTransportInfo.fifoRoom); \
-  GR_ASSERT((((FxU32)tPackPtr) + ((__nVerts) * (__vertSize)) + sizeof(FxU32)) < \
-            (FxU32)gc->cmdTransportInfo.fifoEnd); \
+  GR_ASSERT((((AnyPtr)tPackPtr) + ((__nVerts) * (__vertSize)) + sizeof(FxU32)) < \
+            (AnyPtr)gc->cmdTransportInfo.fifoEnd); \
   GR_ASSERT(nVertex < 0x10); \
   GR_ASSERT(nVertex > 0x00); \
   GR_ASSERT(((__packetHdr) & 0xE0000000UL) == 0x00UL); \
@@ -1052,27 +1063,27 @@ _grH3FifoDump_Linear(const FxU32* const 
   pCount++; \
   GDBG_INFO(gc->myLevel + 200, "\t(0x%X) : V#: 0x%X - P#: 0x%X - ParamVal: (%f : 0x%X)\n", \
             (FxU32)tPackPtr, \
-            ((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
-             (((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
+            ((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
+             (((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
             (((__val) < 786432.875) ? (__val) : ((__val) - 786432.875)), \
             (__floatVal))
 #define SETF_DUMP(__val) \
   pCount++; \
   GDBG_INFO(gc->myLevel + 200, "\t(0x%X) : V#: 0x%X - P#: 0x%X - ParamVal: %f\n", \
             (FxU32)tPackPtr, \
-            ((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
-             (((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
+            ((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
+             (((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
             (((__val) < 786432.875) ? (__val) : ((__val) - 786432.875)))
 #define SET_DUMP(__val) \
   pCount++; \
   GDBG_INFO(gc->myLevel + 200, "\t(0x%X) : V#: 0x%X - P#: 0x%X - ParamVal: 0x%X\n", \
             (FxU32)tPackPtr, \
-            ((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
-             (((FxU32)tPackPtr - ((FxU32)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
+            ((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) / sVertex, \
+             (((AnyPtr)tPackPtr - ((AnyPtr)gc->cmdTransportInfo.fifoPtr + sizeof(FxU32))) % sVertex) >> 2, \
             (__val))
 #define TRI_ASSERT() \
   GR_ASSERT(pCount == (nVertex * (sVertex >> 2))); \
-  ASSERT(((FxU32)tPackPtr - (FxU32)gc->cmdTransportInfo.fifoPtr) == (nVertex * sVertex) + sizeof(FxU32))
+  ASSERT(((AnyPtr)tPackPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr) == (nVertex * sVertex) + sizeof(FxU32))
 #else /* !GDBG_INFO_ON */
 #define DEBUGFIFODUMP_TRI(__packetAddr)
 #define DEBUGFIFODUMP_LINEAR(__packetAddr)
@@ -1137,7 +1148,7 @@ do { \
 
 #define TRI_END \
   TRI_ASSERT(); \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)tPackPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)tPackPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = tPackPtr; \
   GDBG_INFO(gc->myLevel + 200, "\tTriEnd: (0x%X : 0x%X)\n", tPackPtr, gc->cmdTransportInfo.fifoRoom); \
   FIFO_ASSERT(); \
@@ -1156,12 +1167,12 @@ do { \
   GR_CHECK_COMPATABILITY(FN_NAME, \
                          !gc->open, \
                          "Called before grSstWinOpen()"); \
-  GR_ASSERT(((FxU32)(packetPtr) & FIFO_ALIGN_MASK) == 0);        /* alignment */ \
+  GR_ASSERT(((AnyPtr)(packetPtr) & FIFO_ALIGN_MASK) == 0);        /* alignment */ \
   GR_ASSERT((__numWords) > 0);                                   /* packet size */ \
   GR_ASSERT((__numWords) < ((0x01 << 19) - 2)); \
   GR_ASSERT((((FxU32)(__numWords) + 2) << 2) <= (FxU32)gc->cmdTransportInfo.fifoRoom); \
-  GR_ASSERT(((FxU32)packetPtr + (((__numWords) + 2) << 2)) < \
-            (FxU32)gc->cmdTransportInfo.fifoEnd); \
+  GR_ASSERT(((AnyPtr)packetPtr + (((__numWords) + 2) << 2)) < \
+            (AnyPtr)gc->cmdTransportInfo.fifoEnd); \
   GR_ASSERT((hdr2 & 0xE0000000UL) == 0x00UL); \
   GR_ASSERT(((__addr) & 0x03UL) == 0x00UL); \
   FIFO_ASSERT(); \
@@ -1206,8 +1217,8 @@ do { \
 
 #define FIFO_LINEAR_WRITE_END \
   DEBUGFIFODUMP_LINEAR(gc->cmdTransportInfo.fifoPtr); \
-  GR_ASSERT((((FxU32)packetPtr - (FxU32)gc->cmdTransportInfo.fifoPtr) >> 2) == __writeSize + 2); \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)packetPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  GR_ASSERT((((AnyPtr)packetPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr) >> 2) == __writeSize + 2); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)packetPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = packetPtr; \
   GDBG_INFO(gc->myLevel + 200, "\tLinearEnd: (0x%X : 0x%X)\n", \
             packetPtr, gc->cmdTransportInfo.fifoRoom); \
@@ -1625,7 +1636,7 @@ GR_CHECK_SIZE()
     } \
     else { \
       FxU32 argb; \
-      argb = *((FxU32 *)((int)_s + i)) & 0x00ffffff; \
+      argb = *((FxU32 *)((long)_s + i)) & 0x00ffffff; \
       TRI_SETF(*((float *)&argb)); \
       dataElem++; \
       i = gc->tsuDataList[dataElem]; \
Index: b/glide3x/h5/glide3/src/fxglide.h
===================================================================
--- a/glide3x/h5/glide3/src/fxglide.h
+++ b/glide3x/h5/glide3/src/fxglide.h
@@ -1282,7 +1282,7 @@ typedef struct {
  * the _archXXXX proc list that is selected at grGlideInit time.
  */
 
-#ifndef __linux__
+#if !defined(__linux__) || defined(GLIDE_USE_C_TRISETUP)
 typedef FxI32 (FX_CALL* GrTriSetupProc)(const void *a, const void *b, const void *c);
 #else   /* defined(__linux__) */
 typedef FxI32 (FX_CALL* GrTriSetupProc)(const void *g, const void *a, const void *b, const void *c);
@@ -1564,7 +1564,7 @@ typedef struct GrGC_s
           SET_FIFO(*curFifoPtr++, *curPktData++); \
         } \
         GR_INC_SIZE((__writeCount) * sizeof(FxU32)); \
-        gc->cmdTransportInfo.fifoRoom -= ((FxU32)curFifoPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+        gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)curFifoPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
         gc->cmdTransportInfo.fifoPtr = curFifoPtr; \
       } \
       GR_CHECK_SIZE(); \
@@ -1684,7 +1684,7 @@ typedef struct GrGC_s
                           */
     
     FxU32* fifoPtr;      /* Current write pointer into fifo */
-    FxU32  fifoRead;     /* Last known hw read ptr. 
+    AnyPtr  fifoRead;     /* Last known hw read ptr. 
                           * If on an sli enabled system this will be
                           * the 'closest' hw read ptr of the sli
                           * master and slave.
@@ -1756,7 +1756,7 @@ typedef struct GrGC_s
                                    occur every 64K writes. */
 
   } cmdTransportInfo;
-#ifndef	__linux__
+#if !defined(__linux__) || defined(GLIDE_USE_C_TRISETUP)
   FxI32 (FX_CALL *triSetupProc)(const void *a, const void *b, const void *c);
 #else	/* defined(__linux__) */
   FxI32 (FX_CALL *triSetupProc)(const void *g, const void *a, const void *b, const void *c);
@@ -1775,17 +1775,19 @@ typedef struct GrGC_s
   SstCRegs
     *slaveCRegs[3] ;            /* AJB - ptrs to slave chips cmd regs */
   FxU32
-    *rawLfb,
+    *rawLfb;
+  FxU32
     nBuffers,
     curBuffer,
     frontBuffer,
-    backBuffer,
+    backBuffer;
+  AnyPtr
     buffers0[4],
     buffers1[4],
     lfbBuffers[4];              /* Tile relative addresses of the color/aux
                                  * buffers for lfbReads.
                                  */  
-  FxU32 lockPtrs[2];        /* pointers to locked buffers */
+  AnyPtr lockPtrs[2];        /* pointers to locked buffers */
   FxU32 fbStride;
 
   FxBool colTiled,            // AJB - grBufferClear needs to know when target surfaces
@@ -1865,7 +1867,7 @@ typedef struct GrGC_s
   FxI32 expected_counter;       /* the number of bytes expected to be sent */
 
   FxU32 checkCounter;
-  FxU32 checkPtr;
+  AnyPtr checkPtr;
    
   FxVideoTimingInfo* vidTimings;/* init code overrides */
 
@@ -2096,6 +2098,10 @@ extern GrGCFuncs _curGCFuncs;
  * This is the __linux__ code.
  */
 #define P6FENCE asm("xchg %%eax, %0" : : "m" (_GlideRoot.p6Fencer) : "eax");
+#elif defined(__GNUC__) && defined(__alpha__)
+#define P6FENCE asm volatile("mb" ::: "memory")
+#elif defined(__GNUC__) && defined(__ia64__)
+#define P6FENCE asm volatile("mf.a" ::: "memory")
 #else  /* !defined ( P6FENCE ) */
 #  error "P6 Fencing code needs to be added for this compiler"
 #endif /* !defined ( P6FENCE ) */
@@ -2254,7 +2260,11 @@ _trisetup_noclip_valid(const void *va, c
 #define TRISETUP(_a, _b, _c) \
   ((FxI32 (*)(const void *va, const void *vb, const void *vc, GrGC *gc))*gc->triSetupProc)(_a, _b, _c, gc)
 #elif defined(__linux__)
+#ifdef GLIDE_USE_C_TRISETUP
+#define TRISETUP(a, b, c) (gc->triSetupProc)(a, b, c)
+#else
 #define TRISETUP(a, b, c) (gc->triSetupProc)(gc, a, b, c)
+#endif
 #else /* defined(__linux__) */
 #define TRISETUP \
   (*gc->triSetupProc)
@@ -2611,15 +2621,15 @@ getThreadValueFast() {
 #endif
 
 #if (GLIDE_PLATFORM & GLIDE_OS_MACOS)
-extern FxU32 _threadValueMacOS;
-__inline FxU32
+extern AnyPtr _threadValueMacOS;
+__inline AnyPtr
 getThreadValueFast() {
         return _threadValueMacOS;
 }
 #endif
 
 #ifdef __linux__
-extern FxU32 threadValueLinux;
+extern AnyPtr threadValueLinux;
 #define getThreadValueFast() threadValueLinux
 #endif /* defined(__linux__) */
 
@@ -2642,9 +2652,9 @@ void
 freeThreadStorage( void );
 
 void 
-setThreadValue( FxU32 value );
+setThreadValue( AnyPtr value );
 
-FxU32
+AnyPtr
 getThreadValueSLOW( void );
 
 void 
@@ -2882,7 +2892,7 @@ assertDefaultState( void );
                                 saveLevel = gc->myLevel; \
                                 myName = name;  \
                                 gc->myLevel = level; \
-                gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr; \
+                gc->checkPtr = (AnyPtr)gc->cmdTransportInfo.fifoPtr; \
                 GDBG_INFO(gc->myLevel,myName); \
                 FXUNUSED(saveLevel); \
                 FXUNUSED(hw); \
@@ -2893,7 +2903,7 @@ assertDefaultState( void );
                 const char* myName = name;  \
                 GR_ASSERT(gc != NULL);  \
                 gc->myLevel = level; \
-                gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr; \
+                gc->checkPtr = (AnyPtr)gc->cmdTransportInfo.fifoPtr; \
                 GDBG_INFO(gc->myLevel,myName); \
                 FXUNUSED(saveLevel); \
                 FXUNUSED(hw); \
@@ -3056,7 +3066,7 @@ extern FxU32 SST_TEXTURE_ALIGN;
 #define HW_TEX_PTR(__b)        ((FxU32*)(((FxU32)(__b)) + HW_TEXTURE_OFFSET))   
 
 /* access a floating point array with a byte index */
-#define FARRAY(p,i)    (*(float *)((i)+(int)(p)))
+#define FARRAY(p,i)    (*(float *)((i)+(long)(p)))
 #define ArraySize(__a) (sizeof(__a) / sizeof((__a)[0]))
 
 #if GDBG_INFO_ON
Index: b/glide3x/h5/glide3/src/gaa.c
===================================================================
--- a/glide3x/h5/glide3/src/gaa.c
+++ b/glide3x/h5/glide3/src/gaa.c
@@ -388,8 +388,8 @@ aaVpDrawArrayEdgeSense(float *a, float *
   }
   else {
     ia = gc->state.vData.pargbInfo.offset;
-    *((FxU32 *)&v1a)=*((FxU32 *)((int)a + ia))&0x00ffffff;
-    *((FxU32 *)&v2a)=*((FxU32 *)((int)b + ia))&0x00ffffff;
+    *((FxU32 *)&v1a)=*((FxU32 *)((long)a + ia))&0x00ffffff;
+    *((FxU32 *)&v2a)=*((FxU32 *)((long)b + ia))&0x00ffffff;
   }
 
   {
@@ -589,7 +589,7 @@ _grAADrawPoints(FxI32 mode, FxI32 count,
   FxU32 ia;
   FxU32 i;
   FxU32 vsize;
-  FxI32 stride = mode;
+  FxI32 stride;
   FxU32 tmp_cullStripHdr;
 
   GDBG_INFO(94,"_grAADrawPoints(0x%x, %d, 0x%x)\n", mode, count, pointers);
@@ -597,8 +597,10 @@ _grAADrawPoints(FxI32 mode, FxI32 count,
   GDBG_INFO_MORE(gc->myLevel, "(count = %d, pointers = 0x%x)\n",
                  count, pointers);
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof (float *)/sizeof (float);
 
   GR_FLUSH_STATE();
 
@@ -690,7 +692,7 @@ _grAADrawPoints(FxI32 mode, FxI32 count,
               FxU32 argb;
               
               if (i == ia) {
-                argb = *((FxU32 *)((int)e + i)) & 0x00ffffff;
+                argb = *((FxU32 *)((long)e + i)) & 0x00ffffff;
                 TRI_SETF(*((float *)&argb));
               }
               else {
@@ -815,7 +817,7 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
   FxU32 ia, vNum = 0;
   FxU32 vsize;
   FxU32 sCount;
-  FxI32 stride = mode;
+  FxI32 stride;
   FxU32 tmp_cullStripHdr;
 
   GDBG_INFO(95,"_grAADrawLineStrip(count = %d, pointers = 0x%x)\n",
@@ -831,8 +833,11 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
 
   GR_FLUSH_STATE();
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof (float *) / sizeof(float);
+
   if (ltype == GR_LINES)
     sCount = count >> 1; /* line list */
   else
@@ -869,8 +874,8 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
         ady = -ady;
       
       if (gc->state.vData.colorType != GR_FLOAT) {
-        *((FxU32 *)&v1a)=*((FxU32 *)((int)v1 + ia))&0x00ffffff;
-        *((FxU32 *)&v2a)=*((FxU32 *)((int)v2 + ia))&0x00ffffff;
+        *((FxU32 *)&v1a)=*((FxU32 *)((long)v1 + ia))&0x00ffffff;
+        *((FxU32 *)&v2a)=*((FxU32 *)((long)v2 + ia))&0x00ffffff;
       }
       
       if (adx >= ady) {           /* X major line */
@@ -1076,8 +1081,8 @@ _grAADrawLineStrip(FxI32 mode, FxI32 lty
         ady = -ady;
       /*
       if (gc->state.vData.colorType != GR_FLOAT) {
-        *((FxU32 *)&v1a)=*((FxU32 *)((int)v1 + ia))&0x00ffffff;
-        *((FxU32 *)&v2a)=*((FxU32 *)((int)v2 + ia))&0x00ffffff;
+        *((FxU32 *)&v1a)=*((FxU32 *)((long)v1 + ia))&0x00ffffff;
+        *((FxU32 *)&v2a)=*((FxU32 *)((long)v2 + ia))&0x00ffffff;
       }
       */
       
@@ -1270,8 +1275,8 @@ aaDrawArrayEdgeSense(float *a, float *b,
   }
   else {
     ia = gc->state.vData.pargbInfo.offset;
-    *((FxU32 *)&v1a)=*((FxU32 *)((int)a + ia))&0x00ffffff;
-    *((FxU32 *)&v2a)=*((FxU32 *)((int)b + ia))&0x00ffffff;
+    *((FxU32 *)&v1a)=*((FxU32 *)((long)a + ia))&0x00ffffff;
+    *((FxU32 *)&v2a)=*((FxU32 *)((long)b + ia))&0x00ffffff;
   }
 
   {
@@ -1350,7 +1355,7 @@ _grAADrawTriangles(FxI32 mode, FxI32 tty
   float **lPtr = (float **)pointers;
   FxI32 tCount = 3;
   FxU32 fbzModeOld;                 /* Squirrel away current fbzMode */
-  FxI32 stride = mode;
+  FxI32 stride;
   FxI32 xindex = (gc->state.vData.vertexInfo.offset >> 2);
   FxI32 yindex = xindex + 1;
 
@@ -1367,8 +1372,10 @@ _grAADrawTriangles(FxI32 mode, FxI32 tty
   /* gc->state.invalid |= fbzModeBIT; */
   GR_FLUSH_STATE();
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else 
+    stride = sizeof (float *) / sizeof(float);
 
   /* backfaced or zero area */
   while (tCount <= count) {
@@ -1523,7 +1530,7 @@ _grAAVpDrawTriangles(FxI32 mode, FxI32 t
   float **lPtr = (float **)pointers;
   FxI32 tCount = 3;
   FxU32 fbzModeOld;                 /* Squirrel away current fbzMode */
-  FxI32 stride = mode;
+  FxI32 stride;
   FxI32 xindex = (gc->state.vData.vertexInfo.offset >> 2);
   FxI32 yindex = xindex + 1;
 
@@ -1540,8 +1547,10 @@ _grAAVpDrawTriangles(FxI32 mode, FxI32 t
   /* gc->state.invalid |= fbzModeBIT; */
   GR_FLUSH_STATE();
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float *) / sizeof(float);
 
   /* backfaced or zero area */
   while (tCount <= count) {
@@ -1705,7 +1714,7 @@ _grAADrawVertexList(FxU32 type, FxI32 mo
   float *v[3];
   FxBool flip = FXFALSE;
   FxU32 fbzModeOld;                 /* Squirrel away current fbzMode */
-  FxI32 stride = mode;
+  FxI32 stride;
 
   if (sCount <= 2) return;
 
@@ -1716,8 +1725,10 @@ _grAADrawVertexList(FxU32 type, FxI32 mo
   gc->state.shadow.fbzMode &= ~(SST_ZAWRMASK);
   /* gc->state.invalid |= fbzModeBIT; */
   GR_FLUSH_STATE();
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof (float *) / sizeof(float);
 
   sCount-=2;
   if (type == kSetupFan) {
Index: b/glide3x/h5/glide3/src/gdraw.c
===================================================================
--- a/glide3x/h5/glide3/src/gdraw.c
+++ b/glide3x/h5/glide3/src/gdraw.c
@@ -223,7 +223,7 @@
 #define OUTBOUNDS(a) (OUTBOUNDSX(a) || OUTBOUNDSY(a))
 
 /* access an array of four-byte opaque datums with a byte index */
-#define ARRAY(p,i)    (*(int *)((i)+(int)(p)))
+#define ARRAY(p,i)    (*(int *)((i)+(long)(p)))
 
 /*---------------------------------------------------------------------------
 ** grDrawPoint
@@ -282,10 +282,13 @@ GR_ENTRY(grDrawLine, void, (const void *
         }
 #else
 #ifdef __linux__
-  if (gc->state.grEnableArgs.primitive_smooth_mode & GR_AA_ORDERED_LINES_MASK)
-    _grAADrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, (void *)&a);
-  else
-    _grDrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, (void *)&a);
+  {
+    const void *verts[2] = { a,b };
+    if (gc->state.grEnableArgs.primitive_smooth_mode & GR_AA_ORDERED_LINES_MASK)
+      _grAADrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, verts);
+    else
+      _grDrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, verts);
+  }
 #else	/* defined(__linux__) */
   if (gc->state.grEnableArgs.primitive_smooth_mode & GR_AA_ORDERED_LINES_MASK)
     _grAADrawLineStrip(GR_VTX_PTR_ARRAY, GR_LINES, 2, &(void *)a);
@@ -327,7 +330,7 @@ GR_ENTRY(grDrawTriangle, void, (const vo
     /* HackAlert: Nuke the fifo ptr checking stuff here if we're just
      * debugging the asm tri code.
      */    
-    gc->checkPtr = (FxU32)gc->cmdTransportInfo.fifoPtr;
+    gc->checkPtr = (AnyPtr)gc->cmdTransportInfo.fifoPtr;
     gc->checkCounter = 0;
 #else  /* GLIDE_DEBUG */
     GR_END();
@@ -388,7 +391,7 @@ GR_ENTRY(grDrawTriangle, void, (const vo
   GR_INC_SIZE(sizeof(FxU32))
 
 #define DA_END \
-  gc->cmdTransportInfo.fifoRoom -= ((FxU32)packetPtr - (FxU32)gc->cmdTransportInfo.fifoPtr); \
+  gc->cmdTransportInfo.fifoRoom -= ((AnyPtr)packetPtr - (AnyPtr)gc->cmdTransportInfo.fifoPtr); \
   gc->cmdTransportInfo.fifoPtr = packetPtr; \
   FIFO_ASSERT(); \
 }
@@ -414,7 +417,7 @@ _grDrawPoints(FxI32 mode, FxI32 count, v
    * except the data set up is from the pointer array and 
    * its data layout
    */
-  FxI32 stride = mode;
+  FxI32 stride;
 
   /* we snap to an integer by adding a large enough number that it
    * shoves all fraction bits off the right side of the mantissa.
@@ -449,8 +452,10 @@ _grDrawPoints(FxI32 mode, FxI32 count, v
    */
 #define POINTS_BUFFER  100
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float *) / sizeof(float);
 
   if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS) {
 #ifndef FX_GLIDE_H5_CSIM
@@ -757,7 +762,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
   int j;
   FxI32 sCount;
   FxU32 vertexParamOffset;
-  FxI32 stride = mode;
+  FxI32 stride;
 
 #define  DX gc->pool.ftemp1
 #define ADY gc->pool.ftemp2
@@ -773,8 +778,11 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
 
 #define LINES_BUFFER  100
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else 
+    stride = sizeof(float *) / sizeof(float);
+
   if (ltype == GR_LINES)
     sCount = count >> 1; /* line list */
   else
@@ -802,16 +810,16 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
         ** compute absolute deltas and draw from low Y to high Y
         */
         ADY = FARRAY(b, gc->state.vData.vertexInfo.offset+4) - FARRAY(a, gc->state.vData.vertexInfo.offset+4);
-        i = *(long *)&ADY;
+        i = *(int *)&ADY;
         if (i < 0) {
           float *tv;
           tv = a; a = b; b = tv;
           i ^= 0x80000000;            /* ady = -ady; */
-          (*(long *)&ADY) = i;
+          (*(int *)&ADY) = i;
         }
         
         DX = FARRAY(b, gc->state.vData.vertexInfo.offset) - FARRAY(a, gc->state.vData.vertexInfo.offset);
-        j = *(long *)&DX;
+        j = *(int *)&DX;
         if (j < 0) {
           j ^= 0x80000000;            /* adx = -adx; */
         }
@@ -981,7 +989,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
         ** compute absolute deltas and draw from low Y to high Y
         */
         ADY = tmp2 - tmp1;
-        i = *(long *)&ADY;
+        i = *(int *)&ADY;
         if (i < 0) {
           float *tv;          
           owa = oowb; owb = oowa;
@@ -989,7 +997,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
           fby = tmp1;
           tv = a; a = b; b = tv;
           i ^= 0x80000000;            /* ady = -ady; */
-          (*(long *)&ADY) = i;
+          (*(int *)&ADY) = i;
         }
         fax = FARRAY(a, gc->state.vData.vertexInfo.offset)
           *owa*gc->state.Viewport.hwidth+gc->state.Viewport.ox;
@@ -997,7 +1005,7 @@ _grDrawLineStrip(FxI32 mode, FxI32 ltype
           *owb*gc->state.Viewport.hwidth+gc->state.Viewport.ox;
         
         DX = fbx - fax;
-        j = *(long *)&DX;
+        j = *(int *)&DX;
         if (j < 0) {
           j ^= 0x80000000;            /* adx = -adx; */
         }
@@ -1083,7 +1091,7 @@ _grDrawTriangles_Default(FxI32 mode, FxI
 #if GLIDE_HW_TRI_SETUP && GLIDE_PACKET3_TRI_SETUP
   FxI32
     k;
-  FxI32 stride = mode;
+  FxI32 stride;
   float *vPtr;
 
   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
@@ -1097,9 +1105,10 @@ _grDrawTriangles_Default(FxI32 mode, FxI
   GDBG_INFO(110, "%s:  paramMask = 0x%x\n", FN_NAME, gc->cmdTransportInfo.paramMask);
 #endif
 
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
-
+  else
+    stride = sizeof (float *) / sizeof (float);
 
   gc->stats.trisProcessed+=(count/3);
 
Index: b/glide3x/h5/glide3/src/gerror.c
===================================================================
--- a/glide3x/h5/glide3/src/gerror.c
+++ b/glide3x/h5/glide3/src/gerror.c
@@ -293,7 +293,7 @@ _grAssert(char *exp, char *fileName, int
     
     gdbg_printf("Command Fifo:\n");
     gdbg_printf("\tSoftware:\n");
-    gdbg_printf("\t\tfifoPtr:           0x%X\n", (FxU32)gc->cmdTransportInfo.fifoPtr - (FxU32) gc->rawLfb);
+    gdbg_printf("\t\tfifoPtr:           0x%X\n", (AnyPtr)gc->cmdTransportInfo.fifoPtr - (AnyPtr) gc->rawLfb);
     gdbg_printf("\t\tfifoOffset:        0x%X\n", gc->cmdTransportInfo.fifoOffset); 
     gdbg_printf("\t\tfifoEnd:           0x%X\n", gc->cmdTransportInfo.fifoEnd - gc->rawLfb);
     gdbg_printf("\t\tfifoSize:          0x%X\n", gc->cmdTransportInfo.fifoSize); 
@@ -303,7 +303,7 @@ _grAssert(char *exp, char *fileName, int
 
     if ( !gc->windowed ) {
       gdbg_printf("\tHardware:\n");
-      gdbg_printf("\t\treadPtrL:          0x%X\n", HW_FIFO_PTR(FXTRUE) - (FxU32)gc->rawLfb);
+      gdbg_printf("\t\treadPtrL:          0x%X\n", HW_FIFO_PTR(FXTRUE) - (AnyPtr)gc->rawLfb);
       gdbg_printf("\t\tdepth:             0x%X\n", GR_CAGP_GET(depth));
       gdbg_printf("\t\tholeCount:         0x%X\n", GR_CAGP_GET(holeCount));
       gdbg_printf("\t\tbaseAddrL:         0x%X\n", GR_CAGP_GET(baseAddrL));
Index: b/glide3x/h5/glide3/src/gglide.c
===================================================================
--- a/glide3x/h5/glide3/src/gglide.c
+++ b/glide3x/h5/glide3/src/gglide.c
@@ -1300,7 +1300,7 @@ _grTriFill(GrColor_t color, FxU32 depth,
       {
         REG_GROUP_SET(hw, stencilMode, (GR_CMP_ALWAYS << SST_STENCIL_FUNC_SHIFT) |
                                        (stencil       << SST_STENCIL_REF_SHIFT)  |
-                                        stencilMode & (SST_STENCIL_WMASK | SST_STENCIL_MASK) |
+                                        (stencilMode & (SST_STENCIL_WMASK | SST_STENCIL_MASK)) |
                                         SST_STENCIL_ENABLE) ;
         REG_GROUP_SET(hw, stencilOp, (GR_STENCILOP_REPLACE << SST_STENCIL_SFAIL_OP_SHIFT) |
                                      (GR_STENCILOP_REPLACE << SST_STENCIL_ZFAIL_OP_SHIFT) |
@@ -2806,8 +2806,8 @@ GR_ENTRY(grDRIBufferSwap, void, (FxU32 s
     for ( i = 0; i < MAX_BUFF_PENDING && j == -1; i++) {
       if (gc->bufferSwaps[i] == 0xffffffff) {
         gc->bufferSwaps[i] =
-          (FxU32) gc->cmdTransportInfo.fifoPtr -
-          (FxU32) gc->cmdTransportInfo.fifoStart; 
+          (AnyPtr) gc->cmdTransportInfo.fifoPtr -
+          (AnyPtr) gc->cmdTransportInfo.fifoStart; 
         j = i;
       }
     }
@@ -3908,7 +3908,7 @@ GR_ENTRY(grGlideShutdown, void, (void))
            * continuing so that any internal glide calls have a valid
            * gc from tls via GR_DCL_GC. F*ck this up at your own peril.
            */
-          setThreadValue((FxU32)gc);
+          setThreadValue((AnyPtr)gc);
 #if (GLIDE_PLATFORM & GLIDE_OS_WIN32)
           /* Flush any remaining commands and cleanup any per gc state */
           grSurfaceReleaseContext((GrContext_t)gc);
Index: b/glide3x/h5/glide3/src/glfb.c
===================================================================
--- a/glide3x/h5/glide3/src/glfb.c
+++ b/glide3x/h5/glide3/src/glfb.c
@@ -648,7 +648,7 @@ GR_ENTRY(grLfbLock, FxBool,(GrLock_t typ
           info->strideInBytes = driInfo.stride;
         } else {
           info->strideInBytes     = gc->bInfo->buffInfo.bufLfbStride;
-      }
+        }
 #else	/* defined(__linux__) */
        /*
         * This is the default for 3D LFBs,
@@ -671,7 +671,7 @@ GR_ENTRY(grLfbLock, FxBool,(GrLock_t typ
         if ( gc->textureBuffer.on && 
            ( buffer == GR_BUFFER_TEXTUREBUFFER_EXT || buffer == GR_BUFFER_TEXTUREAUXBUFFER_EXT ))       {
           if (type == GR_LFB_READ_ONLY) {
-            info->lfbPtr = (void *)((FxU32)gc->rawLfb + gc->textureBuffer.addr);
+            info->lfbPtr = (void *)((AnyPtr)gc->rawLfb + gc->textureBuffer.addr);
             info->strideInBytes     = gc->textureBuffer.stride ;
 #if __POWERPC__
             if(IS_NAPALM(gc->bInfo->pciInfo.deviceID)) {
@@ -693,7 +693,7 @@ GR_ENTRY(grLfbLock, FxBool,(GrLock_t typ
                    (!pixelPipeline) && 
                    /* Origin must be upper left since we will return raw lfb */
                    (origin != GR_ORIGIN_LOWER_LEFT)){
-            info->lfbPtr = (void *)((FxU32)gc->rawLfb + gc->textureBuffer.addr);
+            info->lfbPtr = (void *)((AnyPtr)gc->rawLfb + gc->textureBuffer.addr);
             info->strideInBytes     = gc->textureBuffer.stride ;
             
           } 
@@ -1114,7 +1114,7 @@ _grLfbWriteRegion(FxBool pixPipelineP,
     case GR_LFB_SRC_FMT_ZA16:
       dstData = (FxU32*)(((FxU16*)dstData) + dst_x);
       length  = src_width * 2;
-      aligned = !((int)dstData&0x2);
+      aligned = !((long)dstData&0x2);
       srcJump = src_stride - length;
       dstJump = info.strideInBytes - length;
       if (aligned) {
@@ -1322,7 +1322,7 @@ GR_ENTRY(grLfbReadRegion, FxBool, (GrBuf
       scanline=src_height;
 
       /* set length - alignment fix*/
-      tmp=(((FxU32)src)&2);
+      tmp=(((AnyPtr)src)&2);
       length=src_width * bpp - tmp;
       src_adjust=info.strideInBytes - tmp;
       dst_adjust=dst_stride - tmp;
@@ -1333,7 +1333,7 @@ GR_ENTRY(grLfbReadRegion, FxBool, (GrBuf
       while(src_height--)
       {
          /* adjust starting alignment */
-         if (((FxU32)src)&3)
+         if (((AnyPtr)src)&3)
             *((FxU16 *)dst)++=*((FxU16 *)src)++;
 
          /* read in dwords of pixels */
@@ -1345,12 +1345,12 @@ GR_ENTRY(grLfbReadRegion, FxBool, (GrBuf
             /* copies aligned dwords */
             do
             {
-               *((FxU32 *)(((FxU32)dst) + byte_index))=*((FxU32 *)(((FxU32)src) + byte_index));
+               *((FxU32 *)(((AnyPtr)dst) + byte_index))=*((FxU32 *)(((AnyPtr)src) + byte_index));
             }while((byte_index+=4)<aligned);
 
             /* handle backend misalignment */
             if (byte_index!=(FxU32)length)
-               *((FxU16 *)(((FxU32)dst) + byte_index))=*((FxU16 *)(((FxU32)src) + byte_index));
+               *((FxU16 *)(((AnyPtr)dst) + byte_index))=*((FxU16 *)(((AnyPtr)src) + byte_index));
          }
          /* adjust for next line */
          ((FxU8 *)src)+=src_adjust;
@@ -1404,7 +1404,7 @@ GR_ENTRY(grLfbReadRegion, FxBool, (GrBuf
     length   = src_width * 2;
     dstJump  = dst_stride - length;
     srcJump  = info.strideInBytes - length;
-    aligned  = !((int)srcData&0x2);
+    aligned  = !((long)srcData&0x2);
     odd      = (src_y+src_height) & 0x1;
     
 #if __POWERPC__
Index: b/glide3x/h5/glide3/src/glide.h
===================================================================
--- a/glide3x/h5/glide3/src/glide.h
+++ b/glide3x/h5/glide3/src/glide.h
@@ -56,7 +56,7 @@ typedef FxU32 GrMipMapId_t;
 typedef FxU32 GrStipplePattern_t;
 #endif /* __linux__ */
 typedef FxU8  GrFog_t;
-typedef FxU32 GrContext_t;
+typedef AnyPtr GrContext_t;
 typedef int (FX_CALL *GrProc)();
 
 /*
Index: b/glide3x/h5/glide3/src/gpci.c
===================================================================
--- a/glide3x/h5/glide3/src/gpci.c
+++ b/glide3x/h5/glide3/src/gpci.c
@@ -559,7 +559,7 @@ static GrTriSetupProc _triSetupProcs[][2
   {
     /* Window coords */
     {
-      { _trisetup_Default_win_nocull_valid,   _trisetup_Default_win_cull_valid },
+      { _trisetup_Default_win_nocull_valid, _trisetup_Default_win_cull_valid },
       { _trisetup_Default_win_nocull_invalid, _trisetup_Default_win_cull_invalid },
     },
 
@@ -574,8 +574,8 @@ static GrTriSetupProc _triSetupProcs[][2
   {
     /* Window coords */
     {
-      { _trisetup_3DNow_win_nocull_valid,  _trisetup_3DNow_win_cull_valid },
-      { _trisetup_3DNow_win_nocull_invalid,  _trisetup_3DNow_win_cull_invalid },
+      { _trisetup_3DNow_win_nocull_valid, _trisetup_3DNow_win_cull_valid },
+      { _trisetup_3DNow_win_nocull_invalid, _trisetup_3DNow_win_cull_invalid },
     },
     /* Clip coordinates */
     {
@@ -588,14 +588,14 @@ static GrTriSetupProc _triSetupProcs[][2
   {
     /* Window coords */
     {
-      { _trisetup_null, _trisetup_null },
-      { _trisetup_null, _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
     },
 
     /* Clip coordinates */
     {
-      { _trisetup_null, _trisetup_null },
-      { _trisetup_null, _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
+      { (GrTriSetupProc) _trisetup_null, (GrTriSetupProc) _trisetup_null },
     },
   },
 };
@@ -604,7 +604,7 @@ static GrTriSetupProc _triSetupProcs[][2
  * unset for C_TRISETUP. Currently, teh grDrawTriangle code will only
  * vector to the asm code if C_TRISETUP is not set.  
  */
-#if GLIDE_USE_C_TRISETUP || __POWERPC__
+#if GLIDE_USE_C_TRISETUP || __alpha__ || __POWERPC__
 static GrVertexListProc _vertexListProcs[][2] = {
   { _grDrawVertexList, _grDrawVertexList },
 #if GL_AMD3D
@@ -1710,7 +1710,7 @@ DllMain(HANDLE hInst, ULONG  ul_reason_f
       GR_DCL_GC;
 
       /* If there is no current gc in tls then set the current context. */
-      if (gc == NULL) setThreadValue((FxU32)&_GlideRoot.GCs[_GlideRoot.current_sst]);
+      if (gc == NULL) setThreadValue((AnyPtr)&_GlideRoot.GCs[_GlideRoot.current_sst]);
     }
     break;
   case DLL_THREAD_DETACH:
Index: b/glide3x/h5/glide3/src/gsst.c
===================================================================
--- a/glide3x/h5/glide3/src/gsst.c
+++ b/glide3x/h5/glide3/src/gsst.c
@@ -1172,8 +1172,8 @@ initGC ( GrGC *gc ) 
     gc->bufferSwaps[t] = 0xffffffff;
   }
   
-  gc->bufferSwaps[0] = ((FxU32) gc->cmdTransportInfo.fifoPtr -
-                        (FxU32) gc->cmdTransportInfo.fifoStart);
+  gc->bufferSwaps[0] = ((AnyPtr) gc->cmdTransportInfo.fifoPtr -
+                        (AnyPtr) gc->cmdTransportInfo.fifoStart);
   
   gc->swapsPending = 1;
   
@@ -1383,7 +1383,7 @@ GR_ENTRY(grSstWinOpen, GrContext_t, ( Fx
    * current gc. This gc is valid for all threads in the fullscreen
    * context.
    */
-  setThreadValue( (FxU32)&_GlideRoot.GCs[_GlideRoot.current_sst] );
+  setThreadValue( (AnyPtr)&_GlideRoot.GCs[_GlideRoot.current_sst] );
   
   {
     /* Partial Argument Validation */
@@ -1540,7 +1540,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
    * current gc. This gc is valid for all threads in the fullscreen
    * context.
    */
-  setThreadValue( (FxU32)&_GlideRoot.GCs[_GlideRoot.current_sst] );
+  setThreadValue( (AnyPtr)&_GlideRoot.GCs[_GlideRoot.current_sst] );
   
   {
     /* Partial Argument Validation */
@@ -2208,7 +2208,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
     for (buffer = 0; buffer < nColBuffers; buffer++) {
       gc->buffers0[buffer] = bufInfo->colBuffStart0[buffer];
       GDBG_INFO(80, "Buffer %d:  Start: 0x%x\n", buffer, gc->buffers0[buffer]);
-      gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
+      gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
       if (bInfo->buffInfo.enable2ndbuffer) {
         gc->buffers1[buffer] = bufInfo->colBuffStart1[buffer];
         GDBG_INFO(80, "Buffer %d:  Start: 0x%x\n", buffer, gc->buffers1[buffer]);
@@ -2217,7 +2217,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
     if (nAuxBuffers != 0) {
       gc->buffers0[buffer] = bufInfo->auxBuffStart0;
       GDBG_INFO(80, "Aux Buffer:  Start: 0x%x\n", gc->buffers0[buffer]);
-      gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
+      gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
       if (bInfo->buffInfo.enable2ndbuffer) {
         gc->buffers1[buffer] = bufInfo->auxBuffStart1;
         GDBG_INFO(80, "Aux Buffer:  Start: 0x%x\n", gc->buffers1[buffer]);
@@ -2422,7 +2422,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
       for ( buffer = 0; buffer < nColBuffers; buffer++ ) {
         gc->buffers0[buffer] = bufInfo->colBuffStart0[buffer];
         GDBG_INFO(80, "Buffer %d:  Start: 0x%x\n", buffer, gc->buffers0[buffer]);
-        gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
+        gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
         if (bInfo->buffInfo.enable2ndbuffer) {
           gc->buffers1[buffer] = bufInfo->colBuffStart1[buffer];
           GDBG_INFO(80, "Buffer %d:  Start: 0x%x\n", buffer, gc->buffers1[buffer]);
@@ -2431,7 +2431,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
       if (nAuxBuffers != 0) {
         gc->buffers0[buffer] = bufInfo->auxBuffStart0;
         GDBG_INFO(80, "Aux Buffer:  Start: 0x%x\n", gc->buffers0[buffer]);
-        gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
+        gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
         if (bInfo->buffInfo.enable2ndbuffer) {
           gc->buffers1[buffer] = bufInfo->auxBuffStart1;
           GDBG_INFO(80, "Aux Buffer:  Start: 0x%x\n", gc->buffers1[buffer]);
@@ -2581,7 +2581,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
       for ( buffer = 0; buffer < nColBuffers; buffer++ ) {
         gc->buffers0[buffer] = bufInfo->colBuffStart0[buffer];
         GDBG_INFO(80, "Buffer %d:  Start: 0x%x\n", buffer, gc->buffers0[buffer]);
-        gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
+        gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
         if (bInfo->buffInfo.enable2ndbuffer) {
           gc->buffers1[buffer] = bufInfo->colBuffStart1[buffer];
           GDBG_INFO(80, "Buffer %d:  Start: 0x%x\n", buffer, gc->buffers1[buffer]);
@@ -2590,7 +2590,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
       if (nAuxBuffers != 0) {
         gc->buffers0[buffer] = bufInfo->auxBuffStart0;
         GDBG_INFO(80, "Aux Buffer:  Start: 0x%x\n", gc->buffers0[buffer]);
-        gc->lfbBuffers[buffer] = (FxU32)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
+        gc->lfbBuffers[buffer] = (AnyPtr)gc->rawLfb + bufInfo->lfbBuffAddr0[buffer];
         if (bInfo->buffInfo.enable2ndbuffer) {
           gc->buffers1[buffer] = bufInfo->auxBuffStart1;
           GDBG_INFO(80, "Aux Buffer:  Start: 0x%x\n", gc->buffers1[buffer]);
@@ -2743,7 +2743,7 @@ GR_EXT_ENTRY(grSstWinOpenExt, GrContext_
               gcFifo->fifoPtr ); 
     
 #ifdef __linux__
-    _grImportFifo(*driInfo.fifoPtr, *driInfo.fifoRead);
+    _grImportFifo((AnyPtr)*driInfo.fifoPtr, (AnyPtr)*driInfo.fifoRead);
 #endif
 
     /* The hw is now in a usable state from the fifo macros.
@@ -3033,7 +3033,7 @@ GR_ENTRY(grSstWinClose, FxBool, (GrConte
    * the tls gc explicitly otherwise other whacky-ness (read 'random
    * crashes' will ensue). 
    */
-  setThreadValue((FxU32)gc);
+  setThreadValue((AnyPtr)gc);
   if ((gc != NULL) && gc->open) grFlush();
 
   /* Make sure that the user specified gc is not whacked */
@@ -3349,8 +3349,8 @@ GR_ENTRY(grFlush, void, (void))
   if ( gc->windowed ) {
 #ifdef GLIDE_INIT_HWC
     GDBG_INFO(gc->myLevel + 200, FN_NAME": cmdSize(0x%X)\n",
-              ((FxU32)gc->cmdTransportInfo.fifoPtr - 
-               (FxU32)gc->cmdTransportInfo.hwcFifoInfo.cmdBuf.baseAddr));
+              ((AnyPtr)gc->cmdTransportInfo.fifoPtr - 
+               (AnyPtr)gc->cmdTransportInfo.hwcFifoInfo.cmdBuf.baseAddr));
     _FifoFlush();
 #endif
   } else if (!gc->cmdTransportInfo.autoBump) {
Index: b/glide3x/h5/glide3/src/gstrip.c
===================================================================
--- a/glide3x/h5/glide3/src/gstrip.c
+++ b/glide3x/h5/glide3/src/gstrip.c
@@ -173,7 +173,7 @@ _grDrawVertexList(FxU32 pktype, FxU32 ty
   ** simplified code
   */
   FxU32 vSize;
-  FxI32 stride = mode;
+  FxI32 stride;
 
   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
 
@@ -183,8 +183,10 @@ _grDrawVertexList(FxU32 pktype, FxU32 ty
   GR_FLUSH_STATE();
 
   vSize = gc->state.vData.vSize;
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
   /* Draw the first (or possibly only) set.  This is necessary because
      the packet is 3_BDDDDDD, and in the next set, the packet is
Index: b/glide3x/h5/glide3/src/gstrip_ppc.c
===================================================================
--- a/glide3x/h5/glide3/src/gstrip_ppc.c
+++ b/glide3x/h5/glide3/src/gstrip_ppc.c
@@ -177,7 +177,7 @@ _grDrawVertexList(FxU32 pktype, FxU32 ty
   ** simplified code
   */
   FxU32 vSize;
-  FxI32 stride = mode;
+  FxI32 stride;
 
   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
 
@@ -187,8 +187,10 @@ _grDrawVertexList(FxU32 pktype, FxU32 ty
   GR_FLUSH_STATE();
 
   vSize = gc->state.vData.vSize;
-  if (stride == 0)
+  if (mode == 0)
     stride = gc->state.vData.vStride;
+  else
+    stride = sizeof(float*)/sizeof(float);
 
   /* Draw the first (or possibly only) set.  This is necessary because
      the packet is 3_BDDDDDD, and in the next set, the packet is
Index: b/glide3x/h5/glide3/src/gtexdl.c
===================================================================
--- a/glide3x/h5/glide3/src/gtexdl.c
+++ b/glide3x/h5/glide3/src/gtexdl.c
@@ -473,7 +473,7 @@ GR_DDFUNC(_grTexDownloadPalette,
         while(i < start + slopCount) {
           FxU32 entry;
           
-          entry = (0x80000000 | ((i & 0xFE) << 23) | pal->data[i] & 0xFFFFFF);
+          entry = (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF));
           
           gc->state.shadow.paletteRow[i>>3].data[i&7] = entry;
           REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)], entry );
@@ -491,7 +491,7 @@ GR_DDFUNC(_grTexDownloadPalette,
         while(i < endIndex) {
           FxU32 entry;
           
-          entry = (0x80000000 | ((i & 0xFE) << 23) | pal->data[i] & 0xFFFFFF);
+          entry = (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF));
           
           gc->state.shadow.paletteRow[i>>3].data[i&7] = entry;
           REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)], entry );
@@ -510,7 +510,7 @@ GR_DDFUNC(_grTexDownloadPalette,
         while(i <= end) {
           FxU32 entry;
           
-          entry = (0x80000000 | ((i & 0xFE) << 23) | pal->data[i] & 0xFFFFFF);
+          entry = (0x80000000 | ((i & 0xFE) << 23) | (pal->data[i] & 0xFFFFFF));
           
           gc->state.shadow.paletteRow[i>>3].data[i&7] = entry;
           REG_GROUP_SET(hw, nccTable0[4 + (i & 0x07)], entry );
Index: b/glide3x/h5/glide3/src/gthread.c
===================================================================
--- a/glide3x/h5/glide3/src/gthread.c
+++ b/glide3x/h5/glide3/src/gthread.c
@@ -64,13 +64,13 @@ initThreadStorage( void ) 
 
 } /* initThreadStorage */
 
-void setThreadValue( FxU32 value ) {
+void setThreadValue( AnyPtr value ) {
     GR_CHECK_F( "setThreadValue", !threadInit, "Thread storage not initialized\n" );
     TlsSetValue( _GlideRoot.tlsIndex, (void*)value );
 }
 
 #pragma warning (4:4035)        /* No return value */
-FxU32 getThreadValueSLOW( void ) {
+AnyPtr getThreadValueSLOW( void ) {
     GR_CHECK_F( "getThreadValue", !threadInit, "Thread storage not initialized\n" );
 
 #if 0
@@ -125,18 +125,18 @@ void endCriticalSection( void ) {
 #include "fxglide.h"
 #include "fxcmd.h"
 
-FxU32 _threadValueMacOS;
+AnyPtr _threadValueMacOS;
 
 void initThreadStorage(void)
 {
 }
 
-void setThreadValue( FxU32 value )
+void setThreadValue( AnyPtr value )
 {
 	_threadValueMacOS = value;
 }
 
-FxU32 getThreadValueSLOW( void )
+AnyPtr getThreadValueSLOW( void )
 {
 	return _threadValueMacOS;
 }
@@ -169,7 +169,7 @@ void endCriticalSection(void)
 #include "fxglide.h"
 #include "fxcmd.h"
 
-FxU32 threadValueLinux;
+AnyPtr threadValueLinux;
 
 void initThreadStorage(void)
 {
@@ -177,12 +177,12 @@ void initThreadStorage(void)
 
 
 
-void setThreadValue( FxU32 value )
+void setThreadValue( AnyPtr value )
 {
 	threadValueLinux = value;
 }
 
-FxU32 getThreadValueSLOW( void )
+AnyPtr getThreadValueSLOW( void )
 {
 	return threadValueLinux;
 }
Index: b/glide3x/h5/glide3/src/xdraw2.inc.s
===================================================================
--- a/glide3x/h5/glide3/src/xdraw2.inc.s
+++ b/glide3x/h5/glide3/src/xdraw2.inc.s
@@ -160,7 +160,7 @@
 	push %esi	/*  save caller's register variable */
 	push %ebx	/*  save caller's register variable  */
 
-	mov _gc-4(%esp), gc
+	mov _gc(%esp), gc
 	mov _vb-4(%esp) , fb	/*  get base address of vertex B */
 	push %ebp	/*  save frame pointer */
 
@@ -298,7 +298,7 @@ LOCAL(nocull):
 	push %edi	/*  save caller's register variable */
 	push %esi	/*  save caller's register variable  */
 
-	mov _gc-8(%esp) , gc	/*  gc on stack (NOT!!! in edx) from caller */
+	mov %edx , gc	/*  gc in edx from caller */
 	push %ebx	/*  save caller's register variable */
 
 	push %ebp	/*  save frame pointer */
Index: b/glide3x/h5/glide3/src/xtexdl_def.c
===================================================================
--- a/glide3x/h5/glide3/src/xtexdl_def.c
+++ b/glide3x/h5/glide3/src/xtexdl_def.c
@@ -291,7 +291,7 @@ _grTexDownload_Default_8_4(struct GrGC_s
       const FxU32 t0 = *(const FxU32*)src8;
       
       GDBG_INFO(195, "s = %d, t = %d, address = 0x%x\n", s, t,
-                (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
+                (AnyPtr) tex_address - (AnyPtr) gc->tex_ptr + 0x200000);
       
       LINEAR_WRITE_SET_8(tex_address, t0);
       
@@ -384,7 +384,7 @@ _grTexDownload_Default_8_WideS(struct Gr
         t1 = *(const FxU32*)(src8 + 4);
       
       GDBG_INFO(195, "s = %d, t = %d, address = 0x%x\n", s, t,
-                (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
+                (AnyPtr) tex_address - (AnyPtr) gc->tex_ptr + 0x200000);
       
       LINEAR_WRITE_SET_8(tex_address + 0, t0);
       LINEAR_WRITE_SET_8(tex_address + 4, t1);
@@ -544,7 +544,7 @@ _grTexDownload_Default_16_WideS(struct G
       const FxU32 t1 = *(const FxU32*)(src16 + 2);
       
       GDBG_INFO(195, "s = %d, t = %d, address = 0x%x\n", s, t,
-                (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
+                (AnyPtr) tex_address - (AnyPtr) gc->tex_ptr + 0x200000);
       
       LINEAR_WRITE_SET_16(tex_address + 0, t0);
       LINEAR_WRITE_SET_16(tex_address + 4, t1);
@@ -611,7 +611,7 @@ _grTexDownload_Default_32_WideS(struct G
       const FxU32 t1 = *(src32 + 1);
       
       GDBG_INFO(195, "s = %d, t = %d, address = 0x%x\n", s, t,
-                (FxU32) tex_address - (FxU32) gc->tex_ptr + 0x200000);
+                (AnyPtr) tex_address - (AnyPtr) gc->tex_ptr + 0x200000);
       
       LINEAR_WRITE_SET(tex_address,     t0);
       LINEAR_WRITE_SET(tex_address + 4, t1);
Index: b/glide3x/h5/incsrc/fxhal.h
===================================================================
--- a/glide3x/h5/incsrc/fxhal.h
+++ b/glide3x/h5/incsrc/fxhal.h
@@ -105,7 +105,7 @@ FX_ENTRY void   FX_CALL fxHalPutenv(char
 FX_ENTRY HalInfo * FX_CALL fxHalInit(FxU32 flags);
 FX_ENTRY FxU32  FX_CALL fxHalNumBoardsInSystem(void);
 FX_ENTRY SstRegs * FX_CALL fxHalMapBoard(FxU32 boardNum);
-FX_ENTRY FxBool FX_CALL fxHalInitCmdFifo( SstRegs *sst, int which, FxU32 fifoStart,
+FX_ENTRY FxBool FX_CALL fxHalInitCmdFifo( SstRegs *sst, int which, AnyPtr fifoStart,
                   FxU32 size, FxBool directExec, FxBool disableHoles, FxBool agpEnable);
 FX_ENTRY FxBool FX_CALL fxHalInitRegisters(SstRegs *sst);
 FX_ENTRY FxBool FX_CALL fxHalInitRenderingRegisters(SstRegs *sst);
@@ -212,9 +212,18 @@ fxHalInitVideoOverlaySurface(
         #define AGPWRP(aHi,aLo,d)  AGPWRV( *agpPhysToVirt(aHi,aLo), d )
         #define AGPRDP(aHi,aLo)    AGPRDV( *agpPhysToVirt(aHi,aLo) )
 #else  // #ifdef HAL_CSIM                          // REAL hw
+#ifdef __alpha__
+extern unsigned char _fxget8(unsigned char *);
+extern unsigned short _fxget16(unsigned short *);
+extern unsigned int _fxget32(unsigned int *);
+	#define GET8(s) _fxget8((unsigned byte *)&s);
+	#define GET16(s) _fxget16((unsigned short *)&s);
+	#define GET(s) _fxget32((unsigned int *)&s);
+#else	
         #define GET8(s) s
         #define GET16(s) s
         #define GET(s) s
+#endif
         #define SET8(d,s) d = s
         #define SET16(d,s) d = s
         #define SET(d,s) d = s
Index: b/glide3x/h5/incsrc/h3defs.h
===================================================================
--- a/glide3x/h5/incsrc/h3defs.h
+++ b/glide3x/h5/incsrc/h3defs.h
@@ -61,11 +61,21 @@
 
 // this crazy macro tests the sign bit of a float by loading it into
 // an integer register and then testing the sign bit of the integer
+#if defined(__LP64__) 
+/* On IA-64, it's faster to do this the obvious way... -davidm 00/08/09 */
+#define FLOAT_ISNEG(f) ((f) < 0.0)
+#else
 #define FLOAT_ISNEG(f) ((*(int *)(&(f))) < 0)
+#endif
 
 // these crazy macros returns the sign of a number (1 if >= 0; -1 if < 0)
+#if defined(__LP64__) 
+#define ISIGN(x) ((x) >= 0 ? 1 : -1)
+#define FSIGN(f) ((f) >= 0.0 ? 1 : -1)
+#else
 #define ISIGN(x) (((x) | 0x40000000L) >> 30)
 #define FSIGN(f) ISIGN(*(long *)&f)
+#endif
 
 #define BIT(n)  (1UL<<(n))
 #define SST_MASK(n) (0xFFFFFFFFL >> (32-(n)))
@@ -2032,9 +2042,9 @@
 
 //----------------- useful addressing macros -----------------------
 // return pointer to SST at specified WRAP, CHIP, or TREX
-#define SST_WRAP(sst,n) ((SstRegs *)((n)*0x4000+(FxI32)(sst)))
-#define SST_CHIP(sst,n) ((SstRegs *)((n)*0x400+(FxI32)(sst)))
-#define SST_TMU(sst,n)  ((SstRegs *)((0x800<<(n))+(FxI32)(sst)))
+#define SST_WRAP(sst,n) ((SstRegs *)((n)*0x4000+(long)(sst)))
+#define SST_CHIP(sst,n) ((SstRegs *)((n)*0x400+(long)(sst)))
+#define SST_TMU(sst,n)  ((SstRegs *)((0x800<<(n))+(long)(sst)))
 #define SST_TREX(sst,n) SST_TMU(sst,n)
 
 // offsets from the base of memBaseAddr0
@@ -2081,7 +2091,7 @@
 
 #define SST_IS_REGISTER_ADDR(a)  ( (a) >= SST_IO_OFFSET         && (a) < SST_TEX_OFFSET )
 
-#define SST_BASE_ADDRESS(sst)   ((FxI32)(sst)-SST_3D_OFFSET)
+#define SST_BASE_ADDRESS(sst)   ((AnyPtr)(sst)-SST_3D_OFFSET)
 #define SST_IO_ADDRESS(sst)     (SST_IO_OFFSET+SST_BASE_ADDRESS(sst))
 #define SST_CMDAGP_ADDRESS(sst) (SST_CMDAGP_OFFSET+SST_BASE_ADDRESS(sst))
 #define SST_GUI_ADDRESS(sst)    (SST_2D_OFFSET+SST_BASE_ADDRESS(sst))
Index: b/glide3x/h5/incsrc/h3regs.h
===================================================================
--- a/glide3x/h5/incsrc/h3regs.h
+++ b/glide3x/h5/incsrc/h3regs.h
@@ -279,11 +279,19 @@ typedef volatile struct sstgregs {      
 
 #ifndef _H2INC
 
+#if defined(__alpha__) || defined(__LP64__)
+typedef unsigned int Reg32u;
+typedef int Reg32;
+#else
+typedef unsigned long Reg32u;
+typedef long Reg32;
+#endif
+
 //----------------- SST chip 3D layout -------------------------
 // registers are in groups of 8 for easy decode
 typedef struct vertex_Rec {
-    unsigned long x;            // 12.4 format
-    unsigned long y;            // 12.4
+    Reg32u x;            // 12.4 format
+    Reg32u y;            // 12.4
 } vtxRec;
 
 typedef volatile struct sstregs {       // THE 3D CHIP
@@ -294,127 +302,127 @@ typedef volatile struct sstregs {       
     vtxRec vB;
     vtxRec vC;
 
-    long r;             // 12.12        Parameters
-    long g;             // 12.12
-    long b;             // 12.12
-    long z;             // 20.12 in 16bpp, 28.4 in 32bpp (there is an ugly hack in csimio.c, search "//EVIL:")
-    long a;             // 12.12
-    long s;             // 14.18
-    long t;             // 14.18
-    long w;             //  2.30
-
-    long drdx;                  // X Gradients
-    long dgdx;
-    long dbdx;
-    long dzdx;  //20.12 in 16bpp, 28.4 in 32bpp (there is an ugly hack in csimio.c, search "//EVIL:")
-    long dadx;
-    long dsdx;
-    long dtdx;
-    long dwdx;
-
-    long drdy;                  // Y Gradients
-    long dgdy;
-    long dbdy;
-    long dzdy;  //20.12 in 16bpp, 28.4 in 32bpp (there is an ugly hack in csimio.c, search "//EVIL:")
-    long dady;
-    long dsdy;
-    long dtdy;
-    long dwdy;
+    Reg32 r;             // 12.12        Parameters
+    Reg32 g;             // 12.12
+    Reg32 b;             // 12.12
+    Reg32 z;             // 20.12 in 16bpp, 28.4 in 32bpp (there is an ugly hack in csimio.c, search "//EVIL:")
+    Reg32 a;             // 12.12
+    Reg32 s;             // 14.18
+    Reg32 t;             // 14.18
+    Reg32 w;             //  2.30
+
+    Reg32 drdx;                  // X Gradients
+    Reg32 dgdx;
+    Reg32 dbdx;
+    Reg32 dzdx;  //20.12 in 16bpp, 28.4 in 32bpp (there is an ugly hack in csimio.c, search "//EVIL:")
+    Reg32 dadx;
+    Reg32 dsdx;
+    Reg32 dtdx;
+    Reg32 dwdx;
+
+    Reg32 drdy;                  // Y Gradients
+    Reg32 dgdy;
+    Reg32 dbdy;
+    Reg32 dzdy;  //20.12 in 16bpp, 28.4 in 32bpp (there is an ugly hack in csimio.c, search "//EVIL:")
+    Reg32 dady;
+    Reg32 dsdy;
+    Reg32 dtdy;
+    Reg32 dwdy;
 
-    unsigned long triangleCMD;  // execute a triangle command (float)
-    unsigned long reservedA;
+    Reg32u triangleCMD;  // execute a triangle command (float)
+    Reg32u reservedA;
     vtxRec FvA;                 // floating point version
     vtxRec FvB;
     vtxRec FvC;
 
-    long Fr;                    // floating point version
-    long Fg;
-    long Fb;
-    long Fz;
-    long Fa;
-    long Fs;
-    long Ft;
-    long Fw;
-
-    long Fdrdx;
-    long Fdgdx;
-    long Fdbdx;
-    long Fdzdx;
-    long Fdadx;
-    long Fdsdx;
-    long Fdtdx;
-    long Fdwdx;
-
-    long Fdrdy;
-    long Fdgdy;
-    long Fdbdy;
-    long Fdzdy;
-    long Fdady;
-    long Fdsdy;
-    long Fdtdy;
-    long Fdwdy;
-
-    unsigned long FtriangleCMD;         // execute a triangle command
-    unsigned long fbzColorPath;         // color select and combine
-    unsigned long fogMode;              // fog Mode
-    unsigned long alphaMode;            // alpha Mode
-    unsigned long fbzMode;              // framebuffer and Z mode
-    unsigned long lfbMode;              // linear framebuffer Mode
-    unsigned long clipLeftRight;        // (6)10(6)10
-    unsigned long clipBottomTop;        // (6)10(6)10
-
-    unsigned long nopCMD;       // execute a nop command
-    unsigned long fastfillCMD;  // execute a fast fill command
-    unsigned long swapbufferCMD;// execute a swapbuffer command
-    unsigned long fogColor;             // (8)888
-    unsigned long zaColor;              // 8.24
-    unsigned long chromaKey;            // (8)888
-    unsigned long chromaRange;
-    unsigned long userIntrCmd;
-
-    unsigned long stipple;              // 32 bits, MSB masks pixels
-    unsigned long c0;                   // 8.8.8.8 (ARGB)
-    unsigned long c1;                   // 8.8.8.8 (ARGB)
+    Reg32 Fr;                    // floating point version
+    Reg32 Fg;
+    Reg32 Fb;
+    Reg32 Fz;
+    Reg32 Fa;
+    Reg32 Fs;
+    Reg32 Ft;
+    Reg32 Fw;
+
+    Reg32 Fdrdx;
+    Reg32 Fdgdx;
+    Reg32 Fdbdx;
+    Reg32 Fdzdx;
+    Reg32 Fdadx;
+    Reg32 Fdsdx;
+    Reg32 Fdtdx;
+    Reg32 Fdwdx;
+
+    Reg32 Fdrdy;
+    Reg32 Fdgdy;
+    Reg32 Fdbdy;
+    Reg32 Fdzdy;
+    Reg32 Fdady;
+    Reg32 Fdsdy;
+    Reg32 Fdtdy;
+    Reg32 Fdwdy;
+
+    Reg32u FtriangleCMD;         // execute a triangle command
+    Reg32u fbzColorPath;         // color select and combine
+    Reg32u fogMode;              // fog Mode
+    Reg32u alphaMode;            // alpha Mode
+    Reg32u fbzMode;              // framebuffer and Z mode
+    Reg32u lfbMode;              // linear framebuffer Mode
+    Reg32u clipLeftRight;        // (6)10(6)10
+    Reg32u clipBottomTop;        // (6)10(6)10
+
+    Reg32u nopCMD;       // execute a nop command
+    Reg32u fastfillCMD;  // execute a fast fill command
+    Reg32u swapbufferCMD;// execute a swapbuffer command
+    Reg32u fogColor;             // (8)888
+    Reg32u zaColor;              // 8.24
+    Reg32u chromaKey;            // (8)888
+    Reg32u chromaRange;
+    Reg32u userIntrCmd;
+
+    Reg32u stipple;              // 32 bits, MSB masks pixels
+    Reg32u c0;                   // 8.8.8.8 (ARGB)
+    Reg32u c1;                   // 8.8.8.8 (ARGB)
     struct {                            // statistic gathering variables
-        unsigned long fbiPixelsIn;
-        unsigned long fbiChromaFail;
-        unsigned long fbiZfuncFail;
-        unsigned long fbiAfuncFail;
-        unsigned long fbiPixelsOut;
+        Reg32u fbiPixelsIn;
+        Reg32u fbiChromaFail;
+        Reg32u fbiZfuncFail;
+        Reg32u fbiAfuncFail;
+        Reg32u fbiPixelsOut;
     } stats;
 
-    unsigned long fogTable[32];         // 64 entries, 2 per word, 2 bytes each
+    Reg32u fogTable[32];         // 64 entries, 2 per word, 2 bytes each
 
-    unsigned long renderMode;		// new 32bpp and 1555 modes
-    unsigned long stencilMode;
-    unsigned long stencilOp;
-    unsigned long colBufferAddr;        //This is the primary colBufferAddr
-    unsigned long colBufferStride;    
-    unsigned long auxBufferAddr;        //This is the primary auxBufferAddr
-    unsigned long auxBufferStride;
-    unsigned long fbiStencilFail;
-
-    unsigned long clipLeftRight1;
-    unsigned long clipBottomTop1;
-    unsigned long combineMode;
-    unsigned long sliCtrl;
-    unsigned long aaCtrl;
-    unsigned long chipMask;
-    unsigned long leftDesktopBuf;
-    unsigned long reservedD[2];         // NOTE: used to store TMUprivate ptr  (reservedD[0])
+    Reg32u renderMode;		// new 32bpp and 1555 modes
+    Reg32u stencilMode;
+    Reg32u stencilOp;
+    Reg32u colBufferAddr;        //This is the primary colBufferAddr
+    Reg32u colBufferStride;    
+    Reg32u auxBufferAddr;        //This is the primary auxBufferAddr
+    Reg32u auxBufferStride;
+    Reg32u fbiStencilFail;
+
+    Reg32u clipLeftRight1;
+    Reg32u clipBottomTop1;
+    Reg32u combineMode;
+    Reg32u sliCtrl;
+    Reg32u aaCtrl;
+    Reg32u chipMask;
+    Reg32u leftDesktopBuf;
+    Reg32u reservedD[2];         // NOTE: used to store TMUprivate ptr  (reservedD[0])
                                         // NOTE: used to store CSIMprivate ptr (reservedD[1])
 
-    unsigned long reservedE[7];         // NOTE: reservedE[0] stores the secondary colBufferAddr
+    Reg32u reservedE[7];         // NOTE: reservedE[0] stores the secondary colBufferAddr
                                         // NOTE: reservedE[1] stores the secondary auxBufferAddr  
                                         // NOTE: reservedE[2] stores the primary colBufferAddr  
                                         // NOTE: reservedE[3] stores the primary auxBufferAddr  
                       
-    unsigned long reservedF[3];  
-    unsigned long swapBufferPend;
-    unsigned long leftOverlayBuf;
-    unsigned long rightOverlayBuf;
-    unsigned long fbiSwapHistory;
-    unsigned long fbiTrianglesOut;      // triangles out counter
+    Reg32u reservedF[3];  
+    Reg32u swapBufferPend;
+    Reg32u leftOverlayBuf;
+    Reg32u rightOverlayBuf;
+    Reg32u fbiSwapHistory;
+    Reg32u fbiTrianglesOut;      // triangles out counter
 
     FxU32 sSetupMode;
     FxU32 sVx;
@@ -436,24 +444,24 @@ typedef volatile struct sstregs {       
 
     FxU32 sDrawTriCMD;
     FxU32 sBeginTriCMD;
-    unsigned long reservedG[6];
+    Reg32u reservedG[6];
 
-    unsigned long reservedH[8];
+    Reg32u reservedH[8];
 
-    unsigned long reservedI[8];
+    Reg32u reservedI[8];
 
-    unsigned long textureMode;          // texture Mode
-    unsigned long tLOD;                 // texture LOD settings
-    unsigned long tDetail;              // texture detail settings
-    unsigned long texBaseAddr;          // current texture base address
-    unsigned long texBaseAddr1;
-    unsigned long texBaseAddr2;
-    unsigned long texBaseAddr38;
-    unsigned long trexInit0;            // hardware init bits
-    unsigned long trexInit1;            // hardware init bits
+    Reg32u textureMode;          // texture Mode
+    Reg32u tLOD;                 // texture LOD settings
+    Reg32u tDetail;              // texture detail settings
+    Reg32u texBaseAddr;          // current texture base address
+    Reg32u texBaseAddr1;
+    Reg32u texBaseAddr2;
+    Reg32u texBaseAddr38;
+    Reg32u trexInit0;            // hardware init bits
+    Reg32u trexInit1;            // hardware init bits
    
-    unsigned long nccTable0[12];        // NCC decode tables, bits are packed
-    unsigned long nccTable1[12];        // 4 words Y, 4 words I, 4 words Q
+    Reg32u nccTable0[12];        // NCC decode tables, bits are packed
+    Reg32u nccTable1[12];        // 4 words Y, 4 words I, 4 words Q
 
 } SstRegs;
 
Index: b/glide3x/h5/minihwc/hwcext.h
===================================================================
--- a/glide3x/h5/minihwc/hwcext.h
+++ b/glide3x/h5/minihwc/hwcext.h
@@ -256,7 +256,8 @@ typedef struct hwcExtLinearAddrReq_s {
 /* Returned from HWCEXT_GETLINEARADDR */
 typedef struct hwcExtLinearAddrRes_s {
   FxU32
-    numBaseAddrs,               /* # base addresses */
+    numBaseAddrs;               /* # base addresses */
+  AnyPtr
     baseAddresses[HWCEXT_MAX_BASEADDR]; /* linear Addresses  */
 } hwcExtLinearAddrRes_t;
 
Index: b/glide3x/h5/minihwc/hwcio.h
===================================================================
--- a/glide3x/h5/minihwc/hwcio.h
+++ b/glide3x/h5/minihwc/hwcio.h
@@ -48,6 +48,12 @@ extern char *cmdAGPRegNames[];
 extern char *waxRegNames[];
 extern char *sstRegNames[];
 
+#ifdef __alpha__
+extern unsigned int _fxget32(unsigned int *);
+#define GET(s) _fxget32((unsigned int *)&s);
+#define SET(d,s) d = s
+#endif
+
 #ifndef GET
 #  define GET(s) s
 #  define SET(d, s)    d = s
Index: b/glide3x/h5/minihwc/linhwc.c
===================================================================
--- a/glide3x/h5/minihwc/linhwc.c
+++ b/glide3x/h5/minihwc/linhwc.c
@@ -67,7 +67,15 @@ hwcCheckMemSize(hwcBoardInfo *bInfo, FxU
 #include "lindri.h"
 
 static FxU32 fenceVar;
+#if defined(__i386__)
 #define P6FENCE asm("xchg %%eax, %0" : : "m" (fenceVar) : "eax");
+#elif defined(__alpha__)
+#define P6FENCE asm volatile("mb" ::: "memory")
+#elif defined(__ia64__)
+#define P6FENCE asm volatile("mf.a" ::: "memory")
+#else
+#error - need to define P6FENCE
+#endif
 
 #define MAXFIFOSIZE     0x40000
 #define FIFOPAD         0x0000
@@ -237,8 +245,8 @@ hwcMapBoard(hwcBoardInfo *bInfo, FxU32 b
   bInfo->linearInfo.initialized = FXTRUE;
   bInfo->osNT = FXFALSE;
   bInfo->procHandle = getpid();
-  bInfo->linearInfo.linearAddress[0]=(FxU32)driInfo.pRegs;
-  bInfo->linearInfo.linearAddress[1]=(FxU32)driInfo.pFB;
+  bInfo->linearInfo.linearAddress[0]=(AnyPtr)driInfo.pRegs;
+  bInfo->linearInfo.linearAddress[1]=(AnyPtr)driInfo.pFB;
   return FXTRUE;
 }
 
@@ -974,7 +982,7 @@ char hwcGetCH( void ) {
   return lin_getch();
 }
 
-void grDRIImportFifo(int fifoPtr, int fifoRead)
+void grDRIImportFifo(FxU32 fifoPtr, FxU32 fifoRead)
 {
   _grImportFifo(fifoPtr, fifoRead);
 }
Index: b/glide3x/h5/minihwc/minihwc.c
===================================================================
--- a/glide3x/h5/minihwc/minihwc.c
+++ b/glide3x/h5/minihwc/minihwc.c
@@ -1660,7 +1660,7 @@ hwcMapBoard(hwcBoardInfo *bInfo, FxU32 b
     for (bAddr = 0; bAddr < 2; bAddr++) {
       if ((bAddrMask & (0x01UL << bAddr)) != 0x00UL) {
         bInfo->linearInfo.linearAddress[bAddr] = 
-          (FxU32)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
+          (AnyPtr)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
                                  length, &bInfo->deviceNum, bInfo->boardNum, bAddr);
       }
     }
@@ -1669,13 +1669,13 @@ hwcMapBoard(hwcBoardInfo *bInfo, FxU32 b
      * unconditionally
      */
     bInfo->linearInfo.linearAddress[2] = 
-      (FxU32)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
+      (AnyPtr)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
                              length, &bInfo->deviceNum, bInfo->boardNum, 2);
 
     /* Does the caller want the rom bios? */
     if ((bAddrMask & 0x08UL) != 0x00UL) {
       bInfo->linearInfo.linearAddress[3] = 
-        (FxU32)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
+        (AnyPtr)pciMapCardMulti(bInfo->pciInfo.vendorID, bInfo->pciInfo.deviceID,
                                0x1000000, &bInfo->deviceNum, bInfo->boardNum, 3);
     }
 
Index: b/glide3x/h5/minihwc/minihwc.h
===================================================================
--- a/glide3x/h5/minihwc/minihwc.h
+++ b/glide3x/h5/minihwc/minihwc.h
@@ -315,14 +315,14 @@ typedef struct hwcPCIInfo_s {
 typedef struct hwcLinearInfo_s {
   FxBool
     initialized;
-  FxU32
+  AnyPtr
     linearAddress[HWC_NUM_BASE_ADDR];
 } hwcLinearInfo;
 
 typedef struct hwcRegInfo_s {
   FxBool
     initialized;
-  volatile FxU32
+  volatile AnyPtr
     ioMemBase,                  /* mem base for I/O aliases */
     cmdAGPBase,                 /* CMD/AGP register base */
     waxBase,                    /* 2D register base */
@@ -346,11 +346,14 @@ typedef struct hwcFifoInfo_s {
   FxBool
     agpFifo,
     initialized;
+  AnyPtr
+    agpVirtAddr;
   FxU32
-    agpVirtAddr,
     agpPhysAddr,
-    agpSize,
-    fifoStart,                  /* Beg of fifo (offset from base) */
+    agpSize;
+  AnyPtr
+    fifoStart;                  /* Beg of fifo (offset from base) */
+  FxU32
     fifoLength;                 /* Fifo size in bytes */
 } hwcFifoInfo;
 
Index: b/swlibs/fxmisc/fximg.c
===================================================================
--- a/swlibs/fxmisc/fximg.c
+++ b/swlibs/fxmisc/fximg.c
@@ -1471,8 +1471,8 @@ FxBool _imgWriteP6Header( FILE *stream, 
 	imgErrorString = "Image write error.";
 	if ( 0 > fprintf( stream, "P6\n" ) ) return FXFALSE;
 	if ( 0 > fprintf( stream, "# PPM Comment\n" ) ) return FXFALSE;
-	if ( 0 > fprintf( stream, "%ld ", info->width ) ) return FXFALSE;
-	if ( 0 > fprintf( stream, "%ld\n", info->height ) ) return FXFALSE;
+	if ( 0 > fprintf( stream, "%d ", info->width ) ) return FXFALSE;
+	if ( 0 > fprintf( stream, "%d\n", info->height ) ) return FXFALSE;
 	if ( 0 > fprintf( stream, "255\n" ) ) return FXFALSE;
 	imgErrorString = "No error.";
 	return FXTRUE;
@@ -1948,7 +1948,7 @@ FxBool imgReadFile(const char *filename,
 	if (prefix) {					// if there's a path prefix
 	    char buf[1024], *p;
 	    strcpy(buf,prefix);			// copy and replace semicolon
-	    if ((p = strchr(buf,';'))) *p = '\0';
+	    if ((p = strchr(buf,';')) != NULL) *p = '\0';
 	    fprintf(stderr,buf);
 	    fprintf(stderr,"/");
 	}
Index: b/swlibs/fxmisc/fxos.c
===================================================================
--- a/swlibs/fxmisc/fxos.c
+++ b/swlibs/fxmisc/fxos.c
@@ -98,7 +98,7 @@ FILE *fxFopenPath(const char *filename, 
 
     // first try and open up the file in the current directory
     if (pprefix) *pprefix = NULL;
-    if ((file = fopen(filename,mode)))
+    if ((file = fopen(filename,mode)) != NULL)
         return file;
     if (path == NULL)
         return NULL;
@@ -115,7 +115,7 @@ FILE *fxFopenPath(const char *filename, 
         strcat(nameWithPath,"/");               // add directory separator
         strcat(nameWithPath,filename);          // add filename
         if (pprefix) *pprefix = path;           // save the prefix
-        if ((file = fopen(nameWithPath,mode)))
+        if ((file = fopen(nameWithPath,mode)) != NULL)
             return file;
         path = psemi;                           // advance to next path element
         if (path)
Index: b/swlibs/include/make/makefile.autoconf.bottom
===================================================================
--- a/swlibs/include/make/makefile.autoconf.bottom
+++ b/swlibs/include/make/makefile.autoconf.bottom
@@ -32,9 +32,21 @@ ifeq ("@GLIDE_DEBUG@","true")
 GLIDE_DEBUG_CFLAGS = -O
 GLIDE_DEBUG_CPPFLAGS = -DGDBG_INFO_ON -DGLIDE_DEBUG
 else
+ifeq ("@FX_GLIDE_BUILD_ARCHITECTURE@","alpha")
+GLIDE_DEBUG_GCFLAGS = -O2 -mcpu=ev5
+GLIDE_DEBUG_GDEFS = -fomit-frame-pointer \
+                    -fexpensive-optimizations -mieee -DBIG_OPT
+else
+ifeq ("@FX_GLIDE_BUILD_ARCHITECTURE@","ia64")
+GLIDE_DEBUG_GCFLAGS = -O3
+GLIDE_DEBUG_GDEFS = -fomit-frame-pointer \
+                    -fexpensive-optimizations -ffast-math -DBIG_OPT
+else
 GLIDE_DEBUG_CFLAGS = -O6 -mcpu=i486 -fomit-frame-pointer -funroll-loops \
                      -fexpensive-optimizations -ffast-math -DBIG_OPT
 endif
+endif
+endif
 
 CFLAGS = -Wall -g $(GLIDE_DEBUG_CFLAGS)
 CPPFLAGS = @CPPFLAGS@ $(GLIDE_DEBUG_CPPFLAGS)
Index: b/swlibs/newpci/pcilib/fxlinux.c
===================================================================
--- a/swlibs/newpci/pcilib/fxlinux.c
+++ b/swlibs/newpci/pcilib/fxlinux.c
@@ -35,10 +35,10 @@ static const char* pciIdentifyLinux(void
 static FxBool pciOutputStringLinux(const char *msg);
 static FxBool pciInitializeLinux(void);
 static FxBool pciShutdownLinux(void);
-static FxBool pciMapLinearLinux(FxU32, FxU32 physical_addr, FxU32 *linear_addr,
+static FxBool pciMapLinearLinux(FxU32, FxU32 physical_addr, AnyPtr *linear_addr,
 				FxU32 *length);
-static FxBool pciUnmapLinearLinux(FxU32 linear_addr, FxU32 length);
-static FxBool pciSetPermissionLinux(const FxU32, const FxU32, const FxBool);
+static FxBool pciUnmapLinearLinux(AnyPtr linear_addr, FxU32 length);
+static FxBool pciSetPermissionLinux(const AnyPtr, const FxU32, const FxBool);
 static FxU8 pciPortInByteLinux(unsigned short port);
 static FxU16 pciPortInWordLinux(unsigned short port);
 static FxU32 pciPortInLongLinux(unsigned short port);
@@ -204,7 +204,7 @@ pciShutdownLinux(void)
 
 static FxBool 
 pciMapLinearLinux(FxU32 bus, FxU32 physical_addr,
-		  FxU32 *linear_addr, FxU32 *length) 
+		  AnyPtr *linear_addr, FxU32 *length) 
 {
   int fd;
   if (linuxDevFd!=-1) {
@@ -215,7 +215,7 @@ pciMapLinearLinux(FxU32 bus, FxU32 physi
       return FXFALSE;
     }
   }
-  if (((*linear_addr)=(FxU32)mmap(0, *length, PROT_READ|PROT_WRITE,
+  if (((*linear_addr)=(AnyPtr)mmap(0, *length, PROT_READ|PROT_WRITE,
 				  MAP_SHARED, fd, physical_addr))<0) {
     if (fd!=linuxDevFd) close(fd);
     return FXFALSE;
@@ -225,14 +225,14 @@ pciMapLinearLinux(FxU32 bus, FxU32 physi
 }
 
 static FxBool
-pciUnmapLinearLinux(FxU32 linear_addr, FxU32 length) 
+pciUnmapLinearLinux(AnyPtr linear_addr, FxU32 length) 
 {
   munmap((void*)linear_addr, length);
   return FXTRUE;
 }
 
 static FxBool
-pciSetPermissionLinux(const FxU32 addrBase, const FxU32 addrLen, 
+pciSetPermissionLinux(const AnyPtr addrBase, const FxU32 addrLen, 
 		      const FxBool writePermP)
 {
   return FXTRUE;
Index: b/swlibs/newpci/pcilib/fxpci.c
===================================================================
--- a/swlibs/newpci/pcilib/fxpci.c
+++ b/swlibs/newpci/pcilib/fxpci.c
@@ -55,7 +55,7 @@ static struct {
   struct {
     FxBool
     mapped;
-    FxU32 
+    AnyPtr
     addr;
   } addrList[MAX_PCI_BASEADDRESSES];
 } linearAddressMapList[MAX_PCI_DEVICES];
@@ -279,11 +279,12 @@ _pciUpdateRegister( FxU32 offset, FxU32 
   return;
 } /* _pciUpdateRegister */
 
-static FxU32 
+static AnyPtr
 find_mapped_address(FxU32 device_bus_func_number, FxU32 addrNum) 
 {
   FxU32 
-    i,
+    i;
+  AnyPtr
     retVal = 0x00UL;
 
   for(i = 0; i < MAX_PCI_DEVICES; i++) {
@@ -298,7 +299,7 @@ find_mapped_address(FxU32 device_bus_fun
 }
 
 static void 
-set_mapped_address(FxU32 device_bus_func_number, FxU32 addrNum, FxU32 value) 
+set_mapped_address(FxU32 device_bus_func_number, FxU32 addrNum, AnyPtr value) 
 {
   FxU32 i;
   
@@ -608,18 +609,11 @@ pciSetConfigData( PciRegister reg, FxU32
     return FXFALSE;
   }
 
-  /*
-   * NOTE: This should really be this way, at least for now.
-   *
-   * Changing this to return the value returned by 
-   * pciUpdateRegisterLinux breaks sst1.
-   */
 #ifdef __linux__
   if (hasDev3DfxLinux()) {
-    pciUpdateRegisterLinux( reg.regAddress, *data, reg.sizeInBytes,
-			    device_bus_func_number);
+    return pciUpdateRegisterLinux(reg.regAddress, *data, reg.sizeInBytes,
+				  device_bus_func_number);
     
-    return FXTRUE;
   }
 #endif
   _pciUpdateRegister( reg.regAddress, *data, reg.sizeInBytes,
@@ -709,7 +703,8 @@ pciMapCardMulti(FxU32 vendorID, FxU32 de
                 FxU32 cardNum, FxU32 addressNum)
 {
   FxU32 
-    physAddress, 
+    physAddress;
+  AnyPtr
     virtAddress;
   
   /* 1) open the PCI device and scan it for devices
@@ -720,7 +715,7 @@ pciMapCardMulti(FxU32 vendorID, FxU32 de
 
   /* 3) find the current physcial address of the card */
   pciGetConfigData( baseAddresses[addressNum], *devNum, &physAddress );
-  if (length <= 0) return (FxU32*)length;
+  if (length <= 0) return (FxU32*)(long)length;
 
   /* Mask the memory type information bits off.
    *   [0]: Memory type indicator (0 memory/1 i/o)
@@ -760,7 +755,6 @@ pciMapCardMulti(FxU32 vendorID, FxU32 de
   return (FxU32*)virtAddress;
 } /* pciMapCardMulti */
 
-
 FX_EXPORT FxU32 * FX_CSTYLE
 pciMapCard(FxU32 vendorID, FxU32 deviceID,
            FxI32 length, FxU32 *devNum, FxU32 addressNum)
@@ -769,7 +763,7 @@ pciMapCard(FxU32 vendorID, FxU32 deviceI
 } /* pciMapCard */
 
 FX_EXPORT FxBool FX_CSTYLE
-pciMapPhysicalToLinear( FxU32 *linear_addr, FxU32 physical_addr,
+pciMapPhysicalToLinear( AnyPtr *linear_addr, FxU32 physical_addr,
                         FxU32 *length ) 
 { 
   return pciMapPhysicalDeviceToLinear(linear_addr, 
@@ -778,7 +772,7 @@ pciMapPhysicalToLinear( FxU32 *linear_ad
 } /* pciMapPhysicalToLinear */
 
 FX_ENTRY FxBool FX_CALL 
-pciMapPhysicalDeviceToLinear(FxU32 *linear_addr, 
+pciMapPhysicalDeviceToLinear(AnyPtr *linear_addr, 
                              FxU32 busNumber, FxU32 physical_addr,
                              FxU32 *length)
 {
@@ -788,7 +782,7 @@ pciMapPhysicalDeviceToLinear(FxU32 *line
 
 
 FX_EXPORT void FX_CSTYLE
-pciUnmapPhysical( FxU32 linear_addr, FxU32 length ) 
+pciUnmapPhysical( AnyPtr linear_addr, FxU32 length ) 
 {
   int i,j;
   
@@ -828,7 +822,7 @@ pciOutputDebugString(const char* msg)
 }
 
 FX_EXPORT FxBool FX_CSTYLE
-pciLinearRangeSetPermission(const FxU32 addrBase, const FxU32 addrLen, const FxBool writeableP)
+pciLinearRangeSetPermission(const AnyPtr addrBase, const FxU32 addrLen, const FxBool writeableP)
 {
   return pciLinearRangeSetPermissionDD(addrBase, addrLen, writeableP);
 }
Index: b/swlibs/newpci/pcilib/fxpci.h
===================================================================
--- a/swlibs/newpci/pcilib/fxpci.h
+++ b/swlibs/newpci/pcilib/fxpci.h
@@ -180,15 +180,15 @@ pciSetConfigDataRaw( PciRegister reg, Fx
  * on bus0 which would not work across pci bridges or on agp devices.   
  */
 FX_ENTRY FxBool FX_CALL 
-pciMapPhysicalToLinear(FxU32 *linear_addr, FxU32 physical_addr,FxU32 *length);
+pciMapPhysicalToLinear(AnyPtr *linear_addr, FxU32 physical_addr,FxU32 *length);
 
 FX_ENTRY FxBool FX_CALL 
-pciMapPhysicalDeviceToLinear(FxU32 *linear_addr, 
+pciMapPhysicalDeviceToLinear(AnyPtr *linear_addr, 
                              FxU32 busNumber, FxU32 physical_addr,
                              FxU32 *length);
 
 FX_ENTRY void   FX_CALL 
-pciUnmapPhysical( FxU32 linear_addr, FxU32 length );
+pciUnmapPhysical( AnyPtr linear_addr, FxU32 length );
 
 const char *
 pciGetVendorName( FxU16 vendor_id );
@@ -235,7 +235,7 @@ FX_ENTRY FxBool FX_CALL
 pciOutputDebugString(const char* debugMsg);
 
 FX_ENTRY FxBool FX_CALL
-pciLinearRangeSetPermission(const FxU32 addrBase, const FxU32 addrLen, const FxBool writeableP);
+pciLinearRangeSetPermission(const AnyPtr addrBase, const FxU32 addrLen, const FxBool writeableP);
 
 #define PCI_ERR_NOERR           0
 #define PCI_ERR_WINRTINIT       1
Index: b/swlibs/newpci/pcilib/pcilib.h
===================================================================
--- a/swlibs/newpci/pcilib/pcilib.h
+++ b/swlibs/newpci/pcilib/pcilib.h
@@ -74,13 +74,13 @@ typedef struct {
 
   /* Platform device address management */
   FxBool (*addrMap)(FxU32 busNumber, FxU32 physAddr,
-                    FxU32* linearAddr, FxU32* length);
-  FxBool (*addrUnmap)(FxU32 linearAddr, FxU32 length);
+                    AnyPtr* linearAddr, FxU32* length);
+  FxBool (*addrUnmap)(AnyPtr linearAddr, FxU32 length);
 
   /* Optional things that a platform may or maynot support and clients
    * should not rely on the call to suceed.  
    */
-  FxBool (*addrSetPermission)(const FxU32 addrBase, const FxU32 addrLen,
+  FxBool (*addrSetPermission)(const AnyPtr addrBase, const FxU32 addrLen,
                               const FxBool writePermP);
 
   FxBool (*msrGet)(MSRInfo* in, MSRInfo* out);
Index: b/swlibs/texus/lib/dequant.c
===================================================================
--- a/swlibs/texus/lib/dequant.c
+++ b/swlibs/texus/lib/dequant.c
@@ -160,12 +160,12 @@ _txImgDequantizeRGB332(FxU32 *out, FxU8 
 }
 
 static void
-_txImgDequantizeYIQ422(FxU32 *out, FxU8 *in, int w, int h, const long *yabTable)
+_txImgDequantizeYIQ422(FxU32 *out, FxU8 *in, int w, int h, const FxU32 *yabTable)
 {
     int                         n = w * h;
     FxU32                       pal[256];
 
-    txYABtoPal256((long *)pal, (long *)yabTable);
+    txYABtoPal256(pal, yabTable);
     out += n;
     in  += n;
     while (n--) *--out = pal[*--in] | 0xff000000;
@@ -223,10 +223,10 @@ _txImgDequantizeARGB8332(FxU32 *out, FxU
 }
 
 static void
-_txImgDequantizeAYIQ8422(FxU32 *out, FxU16 *in, int w, int h, const long *yab)
+_txImgDequantizeAYIQ8422(FxU32 *out, FxU16 *in, int w, int h, const FxU32 *yab)
 {
     int         n = w * h;
-    long        pal[256];
+    FxU32       pal[256];
 
     txYABtoPal256(pal, yab);
     out += n;
@@ -348,7 +348,7 @@ txMipDequantize(TxMip *txMip, TxMip *pxM
         case GR_TEXFMT_RGB_332:         _txImgDequantizeRGB332(dst, src, w, h);         
                                                                 break;
         case GR_TEXFMT_YIQ_422:         _txImgDequantizeYIQ422(dst, src, w, h, 
-                                                                        (long *)pxMip->pal); break;
+                                                                        pxMip->pal); break;
         case GR_TEXFMT_A_8:                     _txImgDequantizeA8(dst, src, w, h);             
                                                                 break;
         case GR_TEXFMT_I_8:                     _txImgDequantizeI8(dst, src, w, h);             
@@ -361,7 +361,7 @@ txMipDequantize(TxMip *txMip, TxMip *pxM
         case GR_TEXFMT_ARGB_8332:       _txImgDequantizeARGB8332(dst, src, w, h);       
                                                                 break;
         case GR_TEXFMT_AYIQ_8422:       _txImgDequantizeAYIQ8422(dst, src, w, h, 
-                                                                        (long *)pxMip->pal); break;
+                                                                        pxMip->pal); break;
         case GR_TEXFMT_RGB_565:         _txImgDequantizeRGB565(dst, src, w, h); 
                                                                 break;
         case GR_TEXFMT_ARGB_1555:       _txImgDequantizeARGB1555(dst, src, w, h);       
Index: b/swlibs/texus/lib/mipmap.c
===================================================================
--- a/swlibs/texus/lib/mipmap.c
+++ b/swlibs/texus/lib/mipmap.c
@@ -35,7 +35,7 @@
 #define B3(x)   ((x>>0)&0xFF)
 
 static void
-_txImgHalve(long *outdata, int width, int height, long *indata)
+_txImgHalve(int *outdata, int width, int height, int *indata)
 {
     unsigned int i,j,k;
     unsigned int w,h, *p,sum,*q;
Index: b/swlibs/texus/lib/ncc.c
===================================================================
--- a/swlibs/texus/lib/ncc.c
+++ b/swlibs/texus/lib/ncc.c
@@ -124,7 +124,7 @@ _txPixQuantize_YIQ422_D4x4 (unsigned lon
 }
 
 static void
-_txImgNcc(char *odata, unsigned long *idata, int w, int h, int format, 
+_txImgNcc(char *odata, unsigned int *idata, int w, int h, int format, 
     int dither)
 {
     int (*quantizer)(unsigned long argb, int x, int y, int w);
@@ -308,7 +308,7 @@ txMipNcc(TxMip *pxMip, TxMip *txMip, int
 
 
     if ((dither & TX_DITHER_MASK) == TX_DITHER_ERR) {
-        txYABtoPal256((long *)pxMip->pal, (long *) &ncc.y[0]);
+        txYABtoPal256(pxMip->pal, &ncc.y[0]);
         txDiffuseIndex(pxMip, txMip, pixsize, pxMip->pal, 256);
     }
     else {
Index: b/swlibs/texus/lib/nccnnet.c
===================================================================
--- a/swlibs/texus/lib/nccnnet.c
+++ b/swlibs/texus/lib/nccnnet.c
@@ -88,19 +88,19 @@
 #define MAX_NEURONS             256
 
 typedef struct  _weight {
-    long         r,  g,  b;                             // fixed point, SUBPIXEL precision bits
+    int          r,  g,  b;                             // fixed point, SUBPIXEL precision bits
     int         ir, ig, ib;                             // pure integers, maybe -256 to 255.
 } Weight;
 
 typedef struct  _vector {
     Weight      *py, *pa, *pb;
-    long         r,  g,  b;                             // pure integers, 0 to 255.
+    int         r,  g,  b;                             // pure integers, 0 to 255.
 } Neuron;
 
 static  Weight                  Y[16], A[4], B[4];
 static  Neuron                  N[MAX_NEURONS];
-static  long                    errR, errG, errB, errMax;
-static  long                    totR, totG, totB;
+static  int                     errR, errG, errB, errMax;
+static  int                     totR, totG, totB;
 
 
 #define SUBPIXEL                22
@@ -114,12 +114,12 @@ static  long                    totR, to
                                                 x = ((256 << SUBPIXEL) -1)
 
 static int
-_nn_modifyNeurons(long ir, long ig, long ib)
+_nn_modifyNeurons(int ir, int ig, int ib)
 {
     int         i; 
     int         d0, d1;                         // closest & next closest distance to input
     int         p0, p1;                         // index into the 256 color table.
-    long        d, dr, dg, db;
+    int         d, dr, dg, db;
     Weight      *py, *pa, *pb;
     Neuron      *n;
 
@@ -268,10 +268,10 @@ static void
 txMapPal256toYAB(FxU32 *YAB, FxU8 *map, int nsamples, FxU32 *samples)
 {
     int         i;
-    long        bstR, bstG, bstB, bstMax;
+    int         bstR, bstG, bstB, bstMax;
     int         iterations;                     // track how many inputs have been fed to NN
     int         drySpells;                      // how many inputs since last best case.
-    long        yab2pal[256];
+    int         yab2pal[256];
 
     _nn_initTables();
     /* 
@@ -367,7 +367,7 @@ txMapPal256toYAB(FxU32 *YAB, FxU8 *map, 
      * Replace MSB of samples with index to be used with YAB table.
      */
 
-    txYABtoPal256((long*)yab2pal, (long*)YAB);
+    txYABtoPal256(yab2pal, YAB);
 
     for (i=0; i<nsamples; i++) {
         int             ir, ig, ib;
@@ -388,7 +388,7 @@ txMipNccNNet(TxMip *pxMip, TxMip *txMip,
     int         i, w, h;
     int         ncolors;
     int         pixsize = (pxMip->format == GR_TEXFMT_YIQ_422) ? 1 : 2;
-    long        yabTable[16+12+12];
+    int         yabTable[16+12+12];
     FxU8        map[256];
 
 
@@ -425,7 +425,7 @@ txMipNccNNet(TxMip *pxMip, TxMip *txMip,
          * the 256 color palette generated from the YAB table. This will be 
          * useful for error diffusion dithering.
          */
-        txYABtoPal256((long *)pxMip->pal, (long *)yabTable);
+        txYABtoPal256(pxMip->pal, yabTable);
         txDiffuseIndex(pxMip, txMip, pixsize, pxMip->pal, 256);
     } 
     else {
Index: b/swlibs/texus/lib/pal256.c
===================================================================
--- a/swlibs/texus/lib/pal256.c
+++ b/swlibs/texus/lib/pal256.c
@@ -83,20 +83,20 @@ typedef unsigned char   uchar;
 
 typedef struct {
     float               weightedvar;            /* weighted variance */
-    ulong               mean[3];                        /* centroid */
-    ulong               weight;                         /* # of pixels in box */
-    ulong               freq[3][MAXCOLORS];     /* Projected frequencies */
+    uint                mean[3];                        /* centroid */
+    uint                weight;                         /* # of pixels in box */
+    uint                freq[3][MAXCOLORS];     /* Projected frequencies */
     int                 low[3], high[3];        /* Box extent */
 } Box;
 
 #define COLORMAXI ( 1 << NBITS )
 #if 0
-static ulong    *Histogram;             /* image histogram      */
+static uint    *Histogram;             /* image histogram      */
 #else
-static ulong    Histogram[COLORMAXI*COLORMAXI*COLORMAXI * sizeof(long)];
+static uint     Histogram[COLORMAXI*COLORMAXI*COLORMAXI * sizeof(long)];
 #endif
-static ulong    SumPixels;              /* total # of pixels    */
-static ulong    ColormaxI;              /* # of colors, 2^Bits */
+static uint     SumPixels;              /* total # of pixels    */
+static uint     ColormaxI;              /* # of colors, 2^Bits */
 static Box              _Boxes[MAXCOLORS];
 static Box              *Boxes;                 /* Array of color boxes. */
 
@@ -108,7 +108,7 @@ static int      CutBox(Box *box, Box *ne
 static void     BoxStats(Box *box);
 static int      GreatestVariance(Box *boxes, int n);
 static int      CutBoxes(Box *boxes, int colors);
-static void     QuantHistogram(ulong *pixels, int npixels, Box *box);
+static void     QuantHistogram(uint *pixels, int npixels, Box *box);
 
 /*
  * Perform variance-based color quantization on a 24-bit image.
@@ -135,16 +135,16 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
 
     Boxes = _Boxes;     
 #if 0
-    Histogram = (ulong *) txMalloc(ColormaxI*ColormaxI*ColormaxI * sizeof(long));
+    Histogram = (uint *) txMalloc(ColormaxI*ColormaxI*ColormaxI * sizeof(long));
     rgbmap = txMalloc((1<<NBITS)*(1<<NBITS)*(1<<NBITS));
 #endif
 
     /*
      * Zero-out the projected frequency arrays of the largest box.
      */
-    bzero(Boxes->freq[0], ColormaxI * sizeof(ulong));
-    bzero(Boxes->freq[1], ColormaxI * sizeof(ulong));
-    bzero(Boxes->freq[2], ColormaxI * sizeof(ulong));
+    bzero(Boxes->freq[0], ColormaxI * sizeof(uint));
+    bzero(Boxes->freq[1], ColormaxI * sizeof(uint));
+    bzero(Boxes->freq[2], ColormaxI * sizeof(uint));
     bzero(Histogram, ColormaxI * ColormaxI * ColormaxI * sizeof(long));
 
     /* Feed all bitmaps & generate histogram */
@@ -153,7 +153,7 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
     h = txMip->height;
     for (i=0; i< txMip->depth; i++) {
         SumPixels += w * h;
-        QuantHistogram((ulong *)txMip->data[i], w * h, &Boxes[0]);
+        QuantHistogram((uint *)txMip->data[i], w * h, &Boxes[0]);
         if (w > 1) w >>= 1;
         if (h > 1) h >>= 1;
     }
@@ -166,10 +166,10 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
      * from their 'prequantized' range to 0-FULLINTENSITY.
      */
     for (i = 0; i < OutColors; i++) {
-        ulong   r, g, b;
-        r = (ulong)(Boxes[i].mean[REDI] * Cfactor + 0.5);
-        g = (ulong)(Boxes[i].mean[GREENI] * Cfactor + 0.5);
-        b = (ulong)(Boxes[i].mean[BLUEI] * Cfactor + 0.5);
+        uint   r, g, b;
+        r = (uint)(Boxes[i].mean[REDI] * Cfactor + 0.5);
+        g = (uint)(Boxes[i].mean[GREENI] * Cfactor + 0.5);
+        b = (uint)(Boxes[i].mean[BLUEI] * Cfactor + 0.5);
 
         /*
         r &= 0xff;
@@ -198,11 +198,11 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
         h = txMip->height;
 
         for (i=0; i< txMip->depth; i++) {
-                ulong   *src;
+                uint   *src;
                 uchar   *dst;
                 int             n;
 
-                src = (ulong *) txMip->data[i];
+                src = (uint *) txMip->data[i];
                 dst = (uchar *) pxMip->data[i];
                 n   = w * h;
                 while (n--) {
@@ -242,9 +242,9 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
  * arrays for the first world-encompassing box.
  */
 static void
-QuantHistogram(ulong *pixels, int npixels, Box *box)
+QuantHistogram(uint *pixels, int npixels, Box *box)
 {
-    ulong *rf, *gf, *bf;
+    uint *rf, *gf, *bf;
     uchar rr, gg, bb;
     int         i;
 
@@ -322,7 +322,7 @@ static void
 BoxStats(Box *box)
 {
     int i, color;
-    ulong *freq;
+    uint *freq;
     float mean, var;
 
     if(box->weight == 0) {
@@ -407,7 +407,7 @@ FindCutpoint(Box *box, int color, Box *n
 {
     float u, v, max;
     int i, maxindex, minindex, cutpoint;
-    ulong optweight, curweight;
+    uint optweight, curweight;
 
     if (box->low[color] + 1 == box->high[color])
         return FALSE;   /* Cannot be cut. */
@@ -457,13 +457,13 @@ FindCutpoint(Box *box, int color, Box *n
 static void
 UpdateFrequencies(Box *box1, Box *box2)
 {
-    ulong myfreq, *h;
+    uint myfreq, *h;
     int b, g, r;
     int roff;
 
-    bzero(box1->freq[0], ColormaxI * sizeof(ulong));
-    bzero(box1->freq[1], ColormaxI * sizeof(ulong));
-    bzero(box1->freq[2], ColormaxI * sizeof(ulong)); 
+    bzero(box1->freq[0], ColormaxI * sizeof(uint));
+    bzero(box1->freq[1], ColormaxI * sizeof(uint));
+    bzero(box1->freq[2], ColormaxI * sizeof(uint));
 
     for (r = box1->low[0]; r < box1->high[0]; r++) {
         roff = r << NBITS;
Index: b/swlibs/texus/lib/quantize.c
===================================================================
--- a/swlibs/texus/lib/quantize.c
+++ b/swlibs/texus/lib/quantize.c
@@ -31,15 +31,15 @@
 
 static int 
 dithmat[4][4] = {       {  0,  8,  2, 10 }, 
-						{ 12,  4, 14,  6 }, 
-						{  3, 11,  1,  9 }, 
-						{ 15,  7, 13,  5 }};
+			{ 12,  4, 14,  6 }, 
+			{  3, 11,  1,  9 }, 
+			{ 15,  7, 13,  5 }};
 
 // for error diffusion.
 static int      errR[MAX_TEXWIDTH], errG[MAX_TEXWIDTH], errB[MAX_TEXWIDTH];     
 
 static int
-_txPixQuantize_RGB332( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB332( unsigned int argb, int x, int y, int w)
 {
     return (
                         (((argb>>16) & 0xE0) |
@@ -48,7 +48,7 @@ _txPixQuantize_RGB332( unsigned long arg
 }
 
 static int
-_txPixQuantize_RGB332_D4x4( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB332_D4x4( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -63,7 +63,7 @@ _txPixQuantize_RGB332_D4x4( unsigned lon
 }
 
 static int
-_txPixQuantize_RGB332_DErr( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB332_DErr( unsigned int argb, int x, int y, int w)
 {
     static unsigned char a3[] = {0x00,0x24,0x49,0x6d,0x92,0xb6,0xdb,0xff};
     static unsigned char a2[] = {0x00,0x55,0xaa,0xff};
@@ -120,13 +120,13 @@ _txPixQuantize_RGB332_DErr( unsigned lon
 /* YIQ422 done elsewhere */
 
 static int
-_txPixQuantize_A8( unsigned long argb, int x, int y, int w)
+_txPixQuantize_A8( unsigned int argb, int x, int y, int w)
 {
     return (argb >> 24);
 }
 
 static int
-_txPixQuantize_I8( unsigned long argb, int x, int y, int w)
+_txPixQuantize_I8( unsigned int argb, int x, int y, int w)
 {
     return (
     ((int) (((argb >>16) & 0xFF) * .30F +
@@ -135,7 +135,7 @@ _txPixQuantize_I8( unsigned long argb, i
 }
 
 static int
-_txPixQuantize_AI44( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI44( unsigned int argb, int x, int y, int w)
 {
     return(
         (int)   ((      ((argb>>16) & 0xFF) * .30F +
@@ -145,7 +145,7 @@ _txPixQuantize_AI44( unsigned long argb,
 }
 
 static int
-_txPixQuantize_AI44_D4x4( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI44_D4x4( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -163,7 +163,7 @@ _txPixQuantize_AI44_D4x4( unsigned long 
 }
 
 static int
-_txPixQuantize_AI44_DErr( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI44_DErr( unsigned int argb, int x, int y, int w)
 {
     int ii, t;
     static      int     qi;
@@ -198,7 +198,7 @@ _txPixQuantize_AI44_DErr( unsigned long 
 
 
 static int
-_txPixQuantize_ARGB8332 ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB8332 ( unsigned int argb, int x, int y, int w)
 {
     return (
                          ((argb>>16) & 0xE0) |
@@ -209,7 +209,7 @@ _txPixQuantize_ARGB8332 ( unsigned long 
 
 
 static int
-_txPixQuantize_ARGB8332_D4x4( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB8332_D4x4( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -225,7 +225,7 @@ _txPixQuantize_ARGB8332_D4x4( unsigned l
 }
 
 static int
-_txPixQuantize_ARGB8332_DErr( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB8332_DErr( unsigned int argb, int x, int y, int w)
 {
     int t;
 
@@ -237,7 +237,7 @@ _txPixQuantize_ARGB8332_DErr( unsigned l
 /* AYIQ8422 done elsewhere */
 
 static int
-_txPixQuantize_RGB565( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB565( unsigned int argb, int x, int y, int w)
 {
     return (
                     ((argb >> 8) & 0xF800) |
@@ -246,7 +246,7 @@ _txPixQuantize_RGB565( unsigned long arg
 }
 
 static int
-_txPixQuantize_RGB565_D4x4 ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB565_D4x4 ( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -262,7 +262,7 @@ _txPixQuantize_RGB565_D4x4 ( unsigned lo
 
 
 static int
-_txPixQuantize_RGB565_DErr ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB565_DErr ( unsigned int argb, int x, int y, int w)
 {
     static int          qr, qg, qb;             // quantized incoming values.
     int                         ir, ig, ib;             // incoming values.
@@ -318,7 +318,7 @@ _txPixQuantize_RGB565_DErr ( unsigned lo
 }
 
 static int
-_txPixQuantize_ARGB1555( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB1555( unsigned int argb, int x, int y, int w)
 {
     return (
                     ((argb >> 9) & 0x7C00) |
@@ -328,7 +328,7 @@ _txPixQuantize_ARGB1555( unsigned long a
 }
 
 static int
-_txPixQuantize_ARGB1555_D4x4 ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB1555_D4x4 ( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -344,7 +344,7 @@ _txPixQuantize_ARGB1555_D4x4 ( unsigned 
 }
 
 static int
-_txPixQuantize_ARGB1555_DErr ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB1555_DErr ( unsigned int argb, int x, int y, int w)
 {
     static int          qr, qg, qb;             // quantized incoming values.
     int                         ir, ig, ib;             // incoming values.
@@ -401,7 +401,7 @@ _txPixQuantize_ARGB1555_DErr ( unsigned 
 }
 
 static int
-_txPixQuantize_ARGB4444 (unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB4444 (unsigned int argb, int x, int y, int w)
 {
     return (
                     ((argb >> 12) & 0x0F00) |
@@ -411,7 +411,7 @@ _txPixQuantize_ARGB4444 (unsigned long a
 }
 
 static int
-_txPixQuantize_ARGB4444_D4x4 (unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB4444_D4x4 (unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -427,7 +427,7 @@ _txPixQuantize_ARGB4444_D4x4 (unsigned l
 }
 
 static int
-_txPixQuantize_ARGB4444_DErr (unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB4444_DErr (unsigned int argb, int x, int y, int w)
 {
     static int          qr, qg, qb;             // quantized incoming values.
     int                         ir, ig, ib;             // incoming values.
@@ -484,7 +484,7 @@ _txPixQuantize_ARGB4444_DErr (unsigned l
 }
 
 static int
-_txPixQuantize_AI88( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI88( unsigned int argb, int x, int y, int w)
 {
     return (
     (((int) (((argb >>16) & 0xFF) * .30F +
@@ -498,7 +498,7 @@ _txPixQuantize_AI88( unsigned long argb,
 static void
 _txImgQuantize(char *dst, char *src, int w, int h, FxU32 format, FxU32 dither)
 {
-    int (*quantizer)(unsigned long argb, int x, int y, int w) = NULL;
+    int (*quantizer)(unsigned int argb, int x, int y, int w) = NULL;
     int         x, y;
 
     dither &= TX_DITHER_MASK;
@@ -589,7 +589,7 @@ _txImgQuantize(char *dst, char *src, int
         // 8 bit dst
         for (y=0; y<h; y++) {
                 for (x=0; x<w; x++) {
-                        *dst++ = (*quantizer)(*(unsigned long *)src, x, y, w);
+                        *dst++ = (*quantizer)(*(unsigned int *)src, x, y, w);
                         src += 4;
                 }
         }
@@ -599,7 +599,7 @@ _txImgQuantize(char *dst, char *src, int
 
         for (y=0; y<h; y++) {
                 for (x=0; x<w; x++) {
-                        *dst16++ = (*quantizer)(*(unsigned long *)src, x, y, w);
+                        *dst16++ = (*quantizer)(*(unsigned int *)src, x, y, w);
                         src += 4;
                 }
         }
Index: b/swlibs/texus/lib/rgt.c
===================================================================
--- a/swlibs/texus/lib/rgt.c
+++ b/swlibs/texus/lib/rgt.c
@@ -52,7 +52,7 @@ typedef struct _rgtHeader{
 
 
 
-static void swapShorts(unsigned short *array, long length)
+static void swapShorts(unsigned short *array, int length)
 {
     unsigned short s;
     while (length--) {
@@ -61,7 +61,7 @@ static void swapShorts(unsigned short *a
     }
 }
 
-static void swapLongs(unsigned int *array, long length)
+static void swapLongs(unsigned int *array, int length)
 {
     unsigned int s;
     while (length--) {
@@ -72,7 +72,7 @@ static void swapLongs(unsigned int *arra
 }
 
 // just swap RGB into BGR (leave MSB undefined)
-static void swapRGB(unsigned int *array, long length)
+static void swapRGB(unsigned int *array, int length)
 {
     unsigned int s;
     while (length--) {
@@ -164,7 +164,7 @@ _txReadRGTData( FILE *stream, TxMip *inf
 
 #if 1
         if (swap) {
-            swapRGB((unsigned int *)data32, (long)info->width);
+            swapRGB((unsigned int *)data32, (int)info->width);
         }
 #endif
 
Index: b/swlibs/texus/lib/texus.h
===================================================================
--- a/swlibs/texus/lib/texus.h
+++ b/swlibs/texus/lib/texus.h
@@ -38,8 +38,14 @@ extern "C" { 
 typedef unsigned char   FxU8;
 typedef unsigned short  FxU16;
 typedef short           FxI16;
+#if defined(__alpha__) || defined(__LP64__)
+typedef unsigned int    FxU32;
+typedef int             FxI32;
+#else
 typedef unsigned long   FxU32;
 typedef long            FxI32;
+#endif
+typedef unsigned long   AnyPtr;
 typedef int             FxBool;
 
 /*
Index: b/swlibs/texus/lib/texusint.h
===================================================================
--- a/swlibs/texus/lib/texusint.h
+++ b/swlibs/texus/lib/texusint.h
@@ -67,7 +67,7 @@ int     txGCD(int a, int b);
 int             txAspectRatio(int w, int h);
 void    txPanic(char *);
 void    txError(char *);
-void    txYABtoPal256(long *palette, const long* yabTable);
+void    txYABtoPal256(int *palette, const int* yabTable);
 void    txRectCopy(FxU8 *dst, int dstStride, const FxU8 *src, int srcStride,
                         int width, int height);
 FxBool  txMipAlloc(TxMip *txMip);
@@ -90,7 +90,7 @@ extern  int *explode3;
 
 void    txDiffuseIndex(TxMip *pxMip, TxMip *txMip, int pixsize, 
                 const FxU32 *palette, int       ncolors);
-int             txNearestColor(long ir, long ig, long ib, const FxU32 *pal, int npal);
+int             txNearestColor(int ir, int ig, int ib, const FxU32 *pal, int npal);
 
 FxBool _txReadTGAHeader( FILE *stream, FxU32 cookie, TxMip *info);
 FxBool _txReadTGAData( FILE *stream, TxMip *info);
Index: b/swlibs/texus/lib/util.c
===================================================================
--- a/swlibs/texus/lib/util.c
+++ b/swlibs/texus/lib/util.c
@@ -133,14 +133,14 @@ txGCD(int a, int b)
 }
 
 void
-txYABtoPal256(long *palette, const long* yabTable)
+txYABtoPal256(int *palette, const int* yabTable)
 {
         // Convert YAB table to a 256 color palette 
         // Assume yabTable[] has first 16Y's, 12 A's, 12 B's
 
-        const   long    *Y = yabTable;
-        const   long    *A = yabTable + 16;
-        const   long    *B = yabTable + 16 + 12;
+        const   int    *Y = yabTable;
+        const   int    *A = yabTable + 16;
+        const   int    *B = yabTable + 16 + 12;
         int             i;
 
         for (i=0; i<256; i++) {
@@ -265,7 +265,7 @@ int     _explode3[255+256] = {
 int  *explode3 = &_explode3[255];
 
 int
-txNearestColor(long ir, long ig, long ib, const FxU32 *pal, int ncolors)
+txNearestColor(int ir, int ig, int ib, const FxU32 *pal, int ncolors)
 {
         int             i, d; 
         int             mindist, minpos;                // closest distance to input
Index: b/swlibs/texus2/lib/codec.c
===================================================================
--- a/swlibs/texus2/lib/codec.c
+++ b/swlibs/texus2/lib/codec.c
@@ -753,7 +753,7 @@ encodeColors(int mode, int mixmode, int 
 
         /* Map input colors to closest entry in the palette */
         for (i=0; i<32; i++) {
-            index[i] = bestColor((float *) &input[i][0], fpal, 4);
+            index[i] = bestColor((float *) &input[i][0], (const float (*)[3])fpal, 4);
         }
 
         /* Now encode these into the 128 bits */
@@ -1043,7 +1043,7 @@ again:
         for (i=0; i<32; i++) {  // for each input point
             float   e;
 
-            j = bestColorError((float *) &input[i][0], colors, ncolors, &e);
+            j = bestColorError((float *) &input[i][0], (const float (*)[3])colors, ncolors, &e);
             counts[j] += 1.0f;
             sums[j][0] += (input[i][0]);
             sums[j][1] += (input[i][1]);
@@ -1108,7 +1108,7 @@ again:
             float   dr, dg, db;
             float   e;           /* distance according to the L-infinity metric */
 
-            j = bestColor((float *) &input[i][0], colors, ncolors); /* distance according to the L-squared metric */
+            j = bestColor((float *) &input[i][0], (const float (*)[3])colors, ncolors); /* distance according to the L-squared metric */
             dr = ABS( input[i][0] - colors[j][0] );
             dg = ABS( input[i][1] - colors[j][1] );
             db = ABS( input[i][2] - colors[j][2] );
@@ -1215,7 +1215,7 @@ again:
         for (i=0; i<32; i++) {
             float   e0, e1, e2, e;
 
-            j = bestColorAlpha((float *) &input[i][0], input[i][3], colors, ncolors, lerp);
+            j = bestColorAlpha((float *) &input[i][0], input[i][3], (const float (*)[4])colors, ncolors, lerp);
             if ( !lerp && ( j == 3 )) continue; // transparent black handled specially
             counts[j] += 1.0f;
             deltas[j][0] += (input[i][0] - colors[j][0]) * alpha;
@@ -1298,7 +1298,7 @@ again:
         for (i=0; i<32; i++) {
             float   dr, dg, db, da, e;
 
-            j = bestColorAlpha((float *) &input[i][0], input[i][3], colors, ncolors, lerp);
+            j = bestColorAlpha((float *) &input[i][0], input[i][3], (const float (*)[4])colors, ncolors, lerp);
             if ( !lerp && ( j == 3 )) continue;
             dr = ABS( input[i][0] - colors[j][0] );
             dg = ABS( input[i][1] - colors[j][1] );
@@ -1363,7 +1363,7 @@ encodeAlpha( float input[][3], FxI32  ai
     float   fpal[4][4];
     int     i, index[32];
 
-    vqChromaAlpha( input, ainput, 3, col, lerp);
+    vqChromaAlpha( (const float (*)[3])input, ainput, 3, col, lerp);
 
     if ( lerp ) {
         /* Deal with even block */
@@ -1375,7 +1375,7 @@ encodeAlpha( float input[][3], FxI32  ai
 
         /* Map input colors to closest entry in the palette */
         for (i=0; i<16; i++) {
-            index[i] = bestColorAlpha((float *) &input[i][0], (float)ainput[i], fpal, 4, lerp);
+            index[i] = bestColorAlpha((float *) &input[i][0], (float)ainput[i], (const float (*)[4])fpal, 4, lerp);
         }
 
         /* Now deal with odd block */
@@ -1386,7 +1386,7 @@ encodeAlpha( float input[][3], FxI32  ai
 
         /* Map input colors to closest entry in the palette */
         for (i=16; i<32; i++) {
-            index[i] = bestColorAlpha((float *) &input[i][0], (float)ainput[i], fpal, 4, lerp);
+            index[i] = bestColorAlpha((float *) &input[i][0], (float)ainput[i], (const float (*)[4])fpal, 4, lerp);
         }
     } else { // no interpolation
         p[0] = ARGB( (int)col[0][3], (int) col[0][0], (int) col[0][1], (int) col[0][2]);
@@ -1398,7 +1398,7 @@ encodeAlpha( float input[][3], FxI32  ai
 
         /* Map input colors to closest entry in the palette */
         for (i=0; i<32; i++) {
-            index[i] = bestColorAlpha((float *) &input[i][0], (float)ainput[i], col, 3, lerp);
+            index[i] = bestColorAlpha((float *) &input[i][0], (float)ainput[i], (const float (*)[4])col, 3, lerp);
         }
     } 
 
@@ -1454,7 +1454,7 @@ quantize4bpp_block(float input[][3], FxI
 #endif
 
     // whole block statistics
-    eigenStatistics(32, input, Wvalues, output, Wflo, Wfhi, Wavg /*not used*/, Wmin, Wmax, Werr);
+    eigenStatistics(32, (const float (*)[3])input, Wvalues, output, Wflo, Wfhi, Wavg /*not used*/, Wmin, Wmax, Werr);
 
 #if PRINT
     fprintf(stderr, "NEW TILE----------------------(%4d %4d)\n", globalX, globalY);
@@ -1487,7 +1487,7 @@ quantize4bpp_block(float input[][3], FxI
             return;
 
         case TCC_CHROMA:
-            vqChroma( input, alpha ? 3 : 4, col);
+            vqChroma( (const float (*)[3])input, alpha ? 3 : 4, col);
             encodeColors( TCC_CHROMA, 0, 0,
                 &col[0][0], &col[1][0], &col[2][0], &col[3][0], input, ainput, bits);
             _cc_chroma++;
@@ -1551,7 +1551,7 @@ quantize4bpp_block(float input[][3], FxI
     	}    
 #endif
 
-        vqChroma( input, alpha ? 3 : 4, col);
+        vqChroma( (const float (*)[3])input, alpha ? 3 : 4, col);
         encodeColors( TCC_CHROMA, 0, alpha,
             &col[0][0], &col[1][0], &col[2][0], &col[3][0], input, ainput, bits);
         _cc_chroma++;
Index: b/swlibs/texus2/lib/dequant.c
===================================================================
--- a/swlibs/texus2/lib/dequant.c
+++ b/swlibs/texus2/lib/dequant.c
@@ -158,12 +158,12 @@ _txImgDequantizeRGB332(FxU32 *out, FxU8 
 }
 
 static void
-_txImgDequantizeYIQ422(FxU32 *out, FxU8 *in, int w, int h, const long *yabTable)
+_txImgDequantizeYIQ422(FxU32 *out, FxU8 *in, int w, int h, const FxU32 *yabTable)
 {
     int                         n = w * h;
     FxU32                       pal[256];
 
-    txYABtoPal256((long *)pal, (long *)yabTable);
+    txYABtoPal256(pal, yabTable);
     out += n;
     in  += n;
     while (n--) *--out = pal[*--in] | 0xff000000;
@@ -221,10 +221,10 @@ _txImgDequantizeARGB8332(FxU32 *out, FxU
 }
 
 static void
-_txImgDequantizeAYIQ8422(FxU32 *out, FxU16 *in, int w, int h, const long *yab)
+_txImgDequantizeAYIQ8422(FxU32 *out, FxU16 *in, int w, int h, const FxU32 *yab)
 {
     int         n = w * h;
-    long        pal[256];
+    FxU32       pal[256];
 
     txYABtoPal256(pal, yab);
     out += n;
@@ -339,10 +339,10 @@ _txImgDequantizeRGB888(FxU32 *out, FxU32
 }
 
 static void 
-_txCalcRGBFromYUV(unsigned long y, unsigned long u, unsigned long v, FxU32 *rgb)
+_txCalcRGBFromYUV(unsigned int y, unsigned int u, unsigned int v, FxU32 *rgb)
 {
         FxI32 r, g, b;
-        long  y16, u128, v128;
+        int  y16, u128, v128;
 
         y16 = y - 16;
         u128 = u - 128;
@@ -386,7 +386,7 @@ void 
 _txImgDequantizeYUV(FxU32 *out, FxU16 *in, int w, int h, FxU32 format)
 {
         int i, j, k;
-        unsigned long Y[2], UV[2];
+        unsigned int Y[2], UV[2];
 
 
         k = w * h;
@@ -430,7 +430,7 @@ void 
 _txImgDequantizeAYUV(FxU32 *out, FxU32 *in, int w, int h)
 {
         int           i, k;
-        unsigned long y, u, v;
+        unsigned int y, u, v;
 
         k = w * h;
 
@@ -487,13 +487,13 @@ txMipDequantize(TxMip *txMip, TxMip *pxM
             
         switch(pxMip->format) {
         case GR_TEXFMT_RGB_332:         _txImgDequantizeRGB332(dst, src, w, h); break;
-        case GR_TEXFMT_YIQ_422:         _txImgDequantizeYIQ422(dst, src, w, h, (long *)pxMip->pal); break;
+        case GR_TEXFMT_YIQ_422:         _txImgDequantizeYIQ422(dst, src, w, h, pxMip->pal); break;
         case GR_TEXFMT_A_8:             _txImgDequantizeA8(dst, src, w, h); break;
         case GR_TEXFMT_I_8:             _txImgDequantizeI8(dst, src, w, h); break;
         case GR_TEXFMT_AI_44:           _txImgDequantizeAI44(dst, src, w, h); break;
         case GR_TEXFMT_P_8:             _txImgDequantizeP8(dst, src, w, h, pxMip->pal); break;
         case GR_TEXFMT_ARGB_8332:       _txImgDequantizeARGB8332(dst, src, w, h); break;
-        case GR_TEXFMT_AYIQ_8422:       _txImgDequantizeAYIQ8422(dst, src, w, h, (long *)pxMip->pal); break;
+        case GR_TEXFMT_AYIQ_8422:       _txImgDequantizeAYIQ8422(dst, src, w, h, pxMip->pal); break;
         case GR_TEXFMT_RGB_565:         _txImgDequantizeRGB565(dst, src, w, h); break;
         case GR_TEXFMT_ARGB_1555:       _txImgDequantizeARGB1555(dst, src, w, h); break;
         case GR_TEXFMT_ARGB_4444:       _txImgDequantizeARGB4444(dst, src, w, h); break;
Index: b/swlibs/texus2/lib/eigen.c
===================================================================
--- a/swlibs/texus2/lib/eigen.c
+++ b/swlibs/texus2/lib/eigen.c
@@ -286,7 +286,7 @@ eigenSpace(int n, float *data, float mea
     float   cov[3][3];
 
     covariance(n, (float (*)[3]) data, mean, cov); 
-    eigenVectors(cov, evectors, evalues);
+    eigenVectors((const float (*)[3])cov, evectors, evalues);
 }
 
 /*
Index: b/swlibs/texus2/lib/mipmap.c
===================================================================
--- a/swlibs/texus2/lib/mipmap.c
+++ b/swlibs/texus2/lib/mipmap.c
@@ -32,7 +32,7 @@
 #define B3(x)   ((x>>0)&0xFF)
 
 static void
-_txImgHalve(long *outdata, int width, int height, long *indata)
+_txImgHalve(int *outdata, int width, int height, int *indata)
 {
     unsigned int i,j,k;
     unsigned int w,h, *p,sum,*q;
Index: b/swlibs/texus2/lib/ncc.c
===================================================================
--- a/swlibs/texus2/lib/ncc.c
+++ b/swlibs/texus2/lib/ncc.c
@@ -35,11 +35,11 @@ static struct   {
     int yhist[256], ihist[256], qhist[256];
     int ymin, ymax, imin, imax, qmin, qmax;
     int npixels;
-    int y[16], a[3*4], b[3*4];          // please leave these contiguous
+    FxU32 y[16], a[3*4], b[3*4];          // please leave these contiguous
 } ncc;
 
 static int
-_txPixQuantize_YIQ422 (unsigned long argb, int x, int y, int w)
+_txPixQuantize_YIQ422 (unsigned int argb, int x, int y, int w)
 {
     int         r, g, b; 
     int         iy, ii, iq;
@@ -76,7 +76,7 @@ _txPixQuantize_YIQ422 (unsigned long arg
 
 
 static int
-_txPixQuantize_YIQ422_D4x4 (unsigned long argb, int x, int y, int w)
+_txPixQuantize_YIQ422_D4x4 (unsigned int argb, int x, int y, int w)
 {
     int         r, g, b;
     int         iy, ii, iq;
@@ -121,10 +121,10 @@ _txPixQuantize_YIQ422_D4x4 (unsigned lon
 }
 
 static void
-_txImgNcc(char *odata, unsigned long *idata, int w, int h, int format, 
+_txImgNcc(char *odata, unsigned int *idata, int w, int h, int format, 
     int dither)
 {
-    int (*quantizer)(unsigned long argb, int x, int y, int w);
+    int (*quantizer)(unsigned int argb, int x, int y, int w);
     int         x, y, pixsize;
 
     quantizer = (dither) ? _txPixQuantize_YIQ422_D4x4 : _txPixQuantize_YIQ422;
@@ -305,7 +305,7 @@ txMipNcc(TxMip *pxMip, TxMip *txMip, int
 
 
     if ((dither & TX_DITHER_MASK) == TX_DITHER_ERR) {
-        txYABtoPal256((long *)pxMip->pal, (long *) &ncc.y[0]);
+        txYABtoPal256(pxMip->pal, &ncc.y[0]);
         txDiffuseIndex(pxMip, txMip, pixsize, pxMip->pal, 256);
     }
     else {
Index: b/swlibs/texus2/lib/nccnnet.c
===================================================================
--- a/swlibs/texus2/lib/nccnnet.c
+++ b/swlibs/texus2/lib/nccnnet.c
@@ -85,19 +85,19 @@
 #define MAX_NEURONS             256
 
 typedef struct  _weight {
-    long         r,  g,  b;                             // fixed point, SUBPIXEL precision bits
+    int         r,  g,  b;                             // fixed point, SUBPIXEL precision bits
     int         ir, ig, ib;                             // pure integers, maybe -256 to 255.
 } Weight;
 
 typedef struct  _vector {
     Weight      *py, *pa, *pb;
-    long         r,  g,  b;                             // pure integers, 0 to 255.
+    int         r,  g,  b;                             // pure integers, 0 to 255.
 } Neuron;
 
 static  Weight                  Y[16], A[4], B[4];
 static  Neuron                  N[MAX_NEURONS];
-static  long                    errR, errG, errB, errMax;
-static  long                    totR, totG, totB;
+static  int                    errR, errG, errB, errMax;
+static  int                    totR, totG, totB;
 
 
 #define SUBPIXEL                22
@@ -111,12 +111,12 @@ static  long                    totR, to
                                                 x = ((256 << SUBPIXEL) -1)
 
 static int
-_nn_modifyNeurons(long ir, long ig, long ib)
+_nn_modifyNeurons(int ir, int ig, int ib)
 {
     int         i; 
     int         d0, d1;                         // closest & next closest distance to input
     int         p0, p1;                         // index into the 256 color table.
-    long        d, dr, dg, db;
+    int        d, dr, dg, db;
     Weight      *py, *pa, *pb;
     Neuron      *n;
 
@@ -265,10 +265,10 @@ static void
 txMapPal256toYAB(FxU32 *YAB, FxU8 *map, int nsamples, FxU32 *samples)
 {
     int         i;
-    long        bstR, bstG, bstB, bstMax;
+    int         bstR, bstG, bstB, bstMax;
     int         iterations;                     // track how many inputs have been fed to NN
     int         drySpells;                      // how many inputs since last best case.
-    long        yab2pal[256];
+    FxU32         yab2pal[256];
 
     _nn_initTables();
     /* 
@@ -364,7 +364,7 @@ txMapPal256toYAB(FxU32 *YAB, FxU8 *map, 
      * Replace MSB of samples with index to be used with YAB table.
      */
 
-    txYABtoPal256((long*)yab2pal, (long*)YAB);
+    txYABtoPal256(yab2pal, YAB);
 
     for (i=0; i<nsamples; i++) {
         int             ir, ig, ib;
@@ -385,7 +385,7 @@ txMipNccNNet(TxMip *pxMip, TxMip *txMip,
     int         i, w, h;
     int         ncolors;
     int         pixsize = (pxMip->format == GR_TEXFMT_YIQ_422) ? 1 : 2;
-    long        yabTable[16+12+12];
+    FxU32         yabTable[16+12+12];
     FxU8        map[256];
 
 
@@ -422,7 +422,7 @@ txMipNccNNet(TxMip *pxMip, TxMip *txMip,
          * the 256 color palette generated from the YAB table. This will be 
          * useful for error diffusion dithering.
          */
-        txYABtoPal256((long *)pxMip->pal, (long *)yabTable);
+        txYABtoPal256(pxMip->pal, yabTable);
         txDiffuseIndex(pxMip, txMip, pixsize, pxMip->pal, 256);
     } 
     else {
Index: b/swlibs/texus2/lib/pal256.c
===================================================================
--- a/swlibs/texus2/lib/pal256.c
+++ b/swlibs/texus2/lib/pal256.c
@@ -79,20 +79,20 @@ typedef unsigned short  ushort;
 
 typedef struct {
     float               weightedvar;            /* weighted variance */
-    ulong               mean[3];                        /* centroid */
-    ulong               weight;                         /* # of pixels in box */
-    ulong               freq[3][MAXCOLORS];     /* Projected frequencies */
+    uint                mean[3];                        /* centroid */
+    uint                weight;                         /* # of pixels in box */
+    uint                freq[3][MAXCOLORS];     /* Projected frequencies */
     int                 low[3], high[3];        /* Box extent */
 } Box;
 
 #define COLORMAXI ( 1 << NBITS )
 #if 0
-static ulong    *Histogram;             /* image histogram      */
+static uint    *Histogram;             /* image histogram      */
 #else
-static ulong    Histogram[COLORMAXI*COLORMAXI*COLORMAXI * sizeof(long)];
+static uint    Histogram[COLORMAXI*COLORMAXI*COLORMAXI * sizeof(long)];
 #endif
-static ulong    SumPixels;              /* total # of pixels    */
-static ulong    ColormaxI;              /* # of colors, 2^Bits */
+static uint    SumPixels;              /* total # of pixels    */
+static uint    ColormaxI;              /* # of colors, 2^Bits */
 static Box              _Boxes[MAXCOLORS];
 static Box              *Boxes;                 /* Array of color boxes. */
 
@@ -104,7 +104,7 @@ static int      CutBox(Box *box, Box *ne
 static void     BoxStats(Box *box);
 static int      GreatestVariance(Box *boxes, int n);
 static int      CutBoxes(Box *boxes, int colors);
-static void     QuantHistogram(ulong *pixels, int npixels, Box *box);
+static void     QuantHistogram(uint *pixels, int npixels, Box *box);
 
 /*
  * Perform variance-based color quantization on a 24-bit image.
@@ -131,16 +131,16 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
 
     Boxes = _Boxes;     
 #if 0
-    Histogram = (ulong *) txMalloc(ColormaxI*ColormaxI*ColormaxI * sizeof(long));
+    Histogram = (uint *) txMalloc(ColormaxI*ColormaxI*ColormaxI * sizeof(long));
     rgbmap = txMalloc((1<<NBITS)*(1<<NBITS)*(1<<NBITS));
 #endif
 
     /*
      * Zero-out the projected frequency arrays of the largest box.
      */
-    bzero(Boxes->freq[0], ColormaxI * sizeof(ulong));
-    bzero(Boxes->freq[1], ColormaxI * sizeof(ulong));
-    bzero(Boxes->freq[2], ColormaxI * sizeof(ulong));
+    bzero(Boxes->freq[0], ColormaxI * sizeof(uint));
+    bzero(Boxes->freq[1], ColormaxI * sizeof(uint));
+    bzero(Boxes->freq[2], ColormaxI * sizeof(uint));
     bzero(Histogram, ColormaxI * ColormaxI * ColormaxI * sizeof(long));
 
     /* Feed all bitmaps & generate histogram */
@@ -149,7 +149,7 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
     h = txMip->height;
     for (i=0; i< txMip->depth; i++) {
         SumPixels += w * h;
-        QuantHistogram((ulong *)txMip->data[i], w * h, &Boxes[0]);
+        QuantHistogram((uint *)txMip->data[i], w * h, &Boxes[0]);
         if (w > 1) w >>= 1;
         if (h > 1) h >>= 1;
     }
@@ -162,10 +162,10 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
      * from their 'prequantized' range to 0-FULLINTENSITY.
      */
     for (i = 0; i < OutColors; i++) {
-        ulong   r, g, b;
-        r = (ulong)(Boxes[i].mean[REDI] * Cfactor + 0.5);
-        g = (ulong)(Boxes[i].mean[GREENI] * Cfactor + 0.5);
-        b = (ulong)(Boxes[i].mean[BLUEI] * Cfactor + 0.5);
+        uint   r, g, b;
+        r = (uint)(Boxes[i].mean[REDI] * Cfactor + 0.5);
+        g = (uint)(Boxes[i].mean[GREENI] * Cfactor + 0.5);
+        b = (uint)(Boxes[i].mean[BLUEI] * Cfactor + 0.5);
 
         /*
         r &= 0xff;
@@ -194,11 +194,11 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
         h = txMip->height;
 
         for (i=0; i< txMip->depth; i++) {
-                ulong   *src;
+                uint    *src;
                 uchar   *dst;
                 int             n;
 
-                src = (ulong *) txMip->data[i];
+                src = (uint  *) txMip->data[i];
                 dst = (uchar *) pxMip->data[i];
                 n   = w * h;
                 while (n--) {
@@ -238,9 +238,9 @@ txMipPal256(TxMip *pxMip, TxMip *txMip, 
  * arrays for the first world-encompassing box.
  */
 static void
-QuantHistogram(ulong *pixels, int npixels, Box *box)
+QuantHistogram(uint *pixels, int npixels, Box *box)
 {
-    ulong *rf, *gf, *bf;
+    uint *rf, *gf, *bf;
     uchar rr, gg, bb;
     int         i;
 
@@ -318,7 +318,7 @@ static void
 BoxStats(Box *box)
 {
     int i, color;
-    ulong *freq;
+    uint *freq;
     float mean, var;
 
     if(box->weight == 0) {
@@ -403,7 +403,7 @@ FindCutpoint(Box *box, int color, Box *n
 {
     float u, v, max;
     int i, maxindex, minindex, cutpoint;
-    ulong optweight, curweight;
+    uint optweight, curweight;
 
     if (box->low[color] + 1 == box->high[color])
         return FALSE;   /* Cannot be cut. */
@@ -453,13 +453,13 @@ FindCutpoint(Box *box, int color, Box *n
 static void
 UpdateFrequencies(Box *box1, Box *box2)
 {
-    ulong myfreq, *h;
+    uint myfreq, *h;
     int b, g, r;
     int roff;
 
-    bzero(box1->freq[0], ColormaxI * sizeof(ulong));
-    bzero(box1->freq[1], ColormaxI * sizeof(ulong));
-    bzero(box1->freq[2], ColormaxI * sizeof(ulong)); 
+    bzero(box1->freq[0], ColormaxI * sizeof(uint));
+    bzero(box1->freq[1], ColormaxI * sizeof(uint));
+    bzero(box1->freq[2], ColormaxI * sizeof(uint)); 
 
     for (r = box1->low[0]; r < box1->high[0]; r++) {
         roff = r << NBITS;
Index: b/swlibs/texus2/lib/pal6666.c
===================================================================
--- a/swlibs/texus2/lib/pal6666.c
+++ b/swlibs/texus2/lib/pal6666.c
@@ -80,9 +80,9 @@ typedef unsigned short  ushort;
 
 typedef struct {
     float               weightedvar;              /* weighted variance */
-    ulong               mean[NCOMP];              /* centroid */
-    ulong               weight;                   /* # of pixels in box */
-    ulong               freq[NCOMP][MAXCOLORS];   /* Projected frequencies */
+    uint                mean[NCOMP];              /* centroid */
+    uint                weight;                   /* # of pixels in box */
+    uint                freq[NCOMP][MAXCOLORS];   /* Projected frequencies */
     int                 low[NCOMP], high[NCOMP];  /* Box extent */
 } Box;
 
@@ -92,12 +92,12 @@ static uchar inverse_pal[INVERSE_PAL_SIZ
 
 #define COLORMAXI ( 1 << NBITS )
 #if 0
-static ulong    *Histogram;             /* image histogram      */
+static uint    *Histogram;             /* image histogram      */
 #else
-static ulong    Histogram[1<<INVERSE_PAL_TOTAL_BITS];
+static uint    Histogram[1<<INVERSE_PAL_TOTAL_BITS];
 #endif
-static ulong    SumPixels;              /* total # of pixels    */
-static ulong    ColormaxI;              /* # of colors, 2^Bits */
+static uint    SumPixels;              /* total # of pixels    */
+static uint    ColormaxI;              /* # of colors, 2^Bits */
 static Box      _Boxes[MAXCOLORS];
 static Box     *Boxes;                 /* Array of color boxes. */
 
@@ -109,7 +109,7 @@ static int      CutBox(Box *box, Box *ne
 static void     BoxStats(Box *box);
 static int      GreatestVariance(Box *boxes, int n);
 static int      CutBoxes(Box *boxes, int colors);
-static void     QuantHistogram(ulong *pixels, int npixels, Box *box);
+static void     QuantHistogram(uint *pixels, int npixels, Box *box);
 
 /*
  * Perform variance-based color quantization on a 32-bit image.
@@ -136,7 +136,7 @@ txMipPal6666(TxMip *pxMip, TxMip *txMip,
 
     Boxes = _Boxes;     
 #if 0
-    Histogram = (ulong *) txMalloc(INVERSE_PAL_SIZE * sizeof(long));
+    Histogram = (uint *) txMalloc(INVERSE_PAL_SIZE * sizeof(long));
     argbmap = txMalloc(INVERSE_PAL_SIZE);
 #endif
 
@@ -144,10 +144,10 @@ txMipPal6666(TxMip *pxMip, TxMip *txMip,
      * Zero-out the projected frequency arrays of the largest box.
      */
 
-    bzero(Boxes->freq[ALPHAI], ColormaxI * sizeof(ulong));
-    bzero(Boxes->freq[REDI],   ColormaxI * sizeof(ulong));
-    bzero(Boxes->freq[GREENI], ColormaxI * sizeof(ulong));
-    bzero(Boxes->freq[BLUEI],  ColormaxI * sizeof(ulong));
+    bzero(Boxes->freq[ALPHAI], ColormaxI * sizeof(uint));
+    bzero(Boxes->freq[REDI],   ColormaxI * sizeof(uint));
+    bzero(Boxes->freq[GREENI], ColormaxI * sizeof(uint));
+    bzero(Boxes->freq[BLUEI],  ColormaxI * sizeof(uint));
 
     bzero(Histogram, INVERSE_PAL_SIZE * sizeof(long));
 
@@ -157,7 +157,7 @@ txMipPal6666(TxMip *pxMip, TxMip *txMip,
     h = txMip->height;
     for (i=0; i< txMip->depth; i++) {
         SumPixels += w * h;
-        QuantHistogram((ulong *)txMip->data[i], w * h, &Boxes[0]);
+        QuantHistogram((uint *)txMip->data[i], w * h, &Boxes[0]);
         if (w > 1) w >>= 1;
         if (h > 1) h >>= 1;
     }
@@ -171,12 +171,12 @@ txMipPal6666(TxMip *pxMip, TxMip *txMip,
      */
 
     for (i = 0; i < OutColors; i++) {
-        ulong  a, r, g, b;
+        uint  a, r, g, b;
 
-        a = (ulong)(Boxes[i].mean[ALPHAI] * Cfactor + 0.5);
-        r = (ulong)(Boxes[i].mean[REDI]   * Cfactor + 0.5);
-        g = (ulong)(Boxes[i].mean[GREENI] * Cfactor + 0.5);
-        b = (ulong)(Boxes[i].mean[BLUEI]  * Cfactor + 0.5);
+        a = (uint)(Boxes[i].mean[ALPHAI] * Cfactor + 0.5);
+        r = (uint)(Boxes[i].mean[REDI]   * Cfactor + 0.5);
+        g = (uint)(Boxes[i].mean[GREENI] * Cfactor + 0.5);
+        b = (uint)(Boxes[i].mean[BLUEI]  * Cfactor + 0.5);
 
         if (a > 255) a = 255;
         if (r > 255) r = 255;
@@ -201,11 +201,11 @@ txMipPal6666(TxMip *pxMip, TxMip *txMip,
         h = txMip->height;
 
         for (i=0; i< txMip->depth; i++) {
-                ulong   *src;
+                uint   *src;
                 uchar   *dst;
                 int             n;
 
-                src = (ulong *) txMip->data[i];
+                src = (uint *) txMip->data[i];
                 dst = (uchar *) pxMip->data[i];
                 n   = w * h;
                 while (n--) {
@@ -246,9 +246,9 @@ txMipPal6666(TxMip *pxMip, TxMip *txMip,
  * arrays for the first world-encompassing box.
  */
 static void
-QuantHistogram(ulong *pixels, int npixels, Box *box)
+QuantHistogram(uint *pixels, int npixels, Box *box)
 {
-    ulong *af, *rf, *gf, *bf;
+    uint *af, *rf, *gf, *bf;
     uchar aa, rr, gg, bb;
     int         i;
 
@@ -327,7 +327,7 @@ static void
 BoxStats(Box *box)
 {
     int i, color;
-    ulong *freq;
+    uint *freq;
     float mean, var;
 
     if(box->weight == 0) {
@@ -417,7 +417,7 @@ FindCutpoint(Box *box, int color, Box *n
 {
     float u, v, max;
     int i, maxindex, minindex, cutpoint;
-    ulong optweight, curweight;
+    uint optweight, curweight;
 
     if (box->low[color] + 1 == box->high[color])
         return FALSE;   /* Cannot be cut. */
@@ -467,13 +467,13 @@ FindCutpoint(Box *box, int color, Box *n
 static void
 UpdateFrequencies(Box *box1, Box *box2)
 {
-    ulong myfreq, *h;
+    uint myfreq, *h;
     int b, g, r, a;
 
-    bzero(box1->freq[ALPHAI], ColormaxI * sizeof(ulong));
-    bzero(box1->freq[REDI],   ColormaxI * sizeof(ulong));
-    bzero(box1->freq[GREENI], ColormaxI * sizeof(ulong));
-    bzero(box1->freq[BLUEI],  ColormaxI * sizeof(ulong)); 
+    bzero(box1->freq[ALPHAI], ColormaxI * sizeof(uint));
+    bzero(box1->freq[REDI],   ColormaxI * sizeof(uint));
+    bzero(box1->freq[GREENI], ColormaxI * sizeof(uint));
+    bzero(box1->freq[BLUEI],  ColormaxI * sizeof(uint)); 
 
     for (a = box1->low[ALPHAI]; a < box1->high[ALPHAI]; a++) {
         for (r = box1->low[REDI]; r < box1->high[REDI]; r++) {
Index: b/swlibs/texus2/lib/quantize.c
===================================================================
--- a/swlibs/texus2/lib/quantize.c
+++ b/swlibs/texus2/lib/quantize.c
@@ -67,7 +67,7 @@ _txDuplicateData(const FxU32 *src, int *
 }
 
 static int
-_txPixQuantize_RGB332( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB332( unsigned int argb, int x, int y, int w)
 {
     return (
             (((argb>>16) & 0xE0) |
@@ -76,7 +76,7 @@ _txPixQuantize_RGB332( unsigned long arg
 }
 
 static int
-_txPixQuantize_RGB332_D4x4( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB332_D4x4( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -91,7 +91,7 @@ _txPixQuantize_RGB332_D4x4( unsigned lon
 }
 
 static int
-_txPixQuantize_RGB332_DErr( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB332_DErr( unsigned int argb, int x, int y, int w)
 {
     static unsigned char a3[] = {0x00,0x24,0x49,0x6d,0x92,0xb6,0xdb,0xff};
     static unsigned char a2[] = {0x00,0x55,0xaa,0xff};
@@ -148,13 +148,13 @@ _txPixQuantize_RGB332_DErr( unsigned lon
 /* YIQ422 done elsewhere */
 
 static int
-_txPixQuantize_A8( unsigned long argb, int x, int y, int w)
+_txPixQuantize_A8( unsigned int argb, int x, int y, int w)
 {
     return (argb >> 24);
 }
 
 static int
-_txPixQuantize_I8( unsigned long argb, int x, int y, int w)
+_txPixQuantize_I8( unsigned int argb, int x, int y, int w)
 {
     return (
     ((int) (((argb >>16) & 0xFF) * .30F +
@@ -163,7 +163,7 @@ _txPixQuantize_I8( unsigned long argb, i
 }
 
 static int
-_txPixQuantize_AI44( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI44( unsigned int argb, int x, int y, int w)
 {
     return(
         (int)   ((      ((argb>>16) & 0xFF) * .30F +
@@ -173,7 +173,7 @@ _txPixQuantize_AI44( unsigned long argb,
 }
 
 static int
-_txPixQuantize_AI44_D4x4( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI44_D4x4( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -191,7 +191,7 @@ _txPixQuantize_AI44_D4x4( unsigned long 
 }
 
 static int
-_txPixQuantize_AI44_DErr( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI44_DErr( unsigned int argb, int x, int y, int w)
 {
     int ii, t;
     static      int     qi;
@@ -226,7 +226,7 @@ _txPixQuantize_AI44_DErr( unsigned long 
 
 
 static int
-_txPixQuantize_ARGB8332 ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB8332 ( unsigned int argb, int x, int y, int w)
 {
     return (
                          ((argb>>16) & 0xE0) |
@@ -237,7 +237,7 @@ _txPixQuantize_ARGB8332 ( unsigned long 
 
 
 static int
-_txPixQuantize_ARGB8332_D4x4( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB8332_D4x4( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -253,7 +253,7 @@ _txPixQuantize_ARGB8332_D4x4( unsigned l
 }
 
 static int
-_txPixQuantize_ARGB8332_DErr( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB8332_DErr( unsigned int argb, int x, int y, int w)
 {
     int t;
 
@@ -265,7 +265,7 @@ _txPixQuantize_ARGB8332_DErr( unsigned l
 /* AYIQ8422 done elsewhere */
 
 static int
-_txPixQuantize_RGB565( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB565( unsigned int argb, int x, int y, int w)
 {
     return (
                     ((argb >> 8) & 0xF800) |
@@ -274,7 +274,7 @@ _txPixQuantize_RGB565( unsigned long arg
 }
 
 static int
-_txPixQuantize_RGB565_D4x4 ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB565_D4x4 ( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -290,7 +290,7 @@ _txPixQuantize_RGB565_D4x4 ( unsigned lo
 
 
 static int
-_txPixQuantize_RGB565_DErr ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_RGB565_DErr ( unsigned int argb, int x, int y, int w)
 {
     static int          qr, qg, qb;             // quantized incoming values.
     int                         ir, ig, ib;             // incoming values.
@@ -346,7 +346,7 @@ _txPixQuantize_RGB565_DErr ( unsigned lo
 }
 
 static int
-_txPixQuantize_ARGB1555( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB1555( unsigned int argb, int x, int y, int w)
 {
     return (
                     ((argb >> 9) & 0x7C00) |
@@ -356,7 +356,7 @@ _txPixQuantize_ARGB1555( unsigned long a
 }
 
 static int
-_txPixQuantize_ARGB1555_D4x4 ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB1555_D4x4 ( unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -372,7 +372,7 @@ _txPixQuantize_ARGB1555_D4x4 ( unsigned 
 }
 
 static int
-_txPixQuantize_ARGB1555_DErr ( unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB1555_DErr ( unsigned int argb, int x, int y, int w)
 {
     static int          qr, qg, qb;             // quantized incoming values.
     int                 ir, ig, ib;             // incoming values.
@@ -429,7 +429,7 @@ _txPixQuantize_ARGB1555_DErr ( unsigned 
 }
 
 static int
-_txPixQuantize_ARGB4444 (unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB4444 (unsigned int argb, int x, int y, int w)
 {
     return (
                     ((argb >> 12) & 0x0F00) |
@@ -439,7 +439,7 @@ _txPixQuantize_ARGB4444 (unsigned long a
 }
 
 static int
-_txPixQuantize_ARGB4444_D4x4 (unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB4444_D4x4 (unsigned int argb, int x, int y, int w)
 {
     int d = dithmat[y&3][x&3];
     int n, t;
@@ -455,7 +455,7 @@ _txPixQuantize_ARGB4444_D4x4 (unsigned l
 }
 
 static int
-_txPixQuantize_ARGB4444_DErr (unsigned long argb, int x, int y, int w)
+_txPixQuantize_ARGB4444_DErr (unsigned int argb, int x, int y, int w)
 {
     static int          qr, qg, qb;             // quantized incoming values.
     int                         ir, ig, ib;             // incoming values.
@@ -512,7 +512,7 @@ _txPixQuantize_ARGB4444_DErr (unsigned l
 }
 
 static int
-_txPixQuantize_AI88( unsigned long argb, int x, int y, int w)
+_txPixQuantize_AI88( unsigned int argb, int x, int y, int w)
 {
     return (
     (((int) (((argb >>16) & 0xFF) * .30F +
@@ -523,7 +523,7 @@ _txPixQuantize_AI88( unsigned long argb,
 }
 
 static void 
-_txCalcYUVFromRGB(FxU32 argb, long *y, long *u, long *v)
+_txCalcYUVFromRGB(FxU32 argb, int *y, int *u, int *v)
 {
         float red, green, blue;
 
@@ -535,22 +535,22 @@ _txCalcYUVFromRGB(FxU32 argb, long *y, l
 
         // ImageMagick method
         /*
-        *y = (long)( 0.29900 * red + 0.58700 * green + 0.11400 * blue );
-        *u = (long)(-0.14740 * red - 0.28950 * green + 0.43690 * blue + 128.5);
-        *v = (long)( 0.61500 * red - 0.51500 * green - 0.10000 * blue + 128.5);
+        *y = (int)( 0.29900 * red + 0.58700 * green + 0.11400 * blue );
+        *u = (int)(-0.14740 * red - 0.28950 * green + 0.43690 * blue + 128.5);
+        *v = (int)( 0.61500 * red - 0.51500 * green - 0.10000 * blue + 128.5);
         */
 
         // MWP method
         /*
-        *y = (long)((77.0 / 256.0) * red + (150.0 / 256.0) * green + (29.0 / 256.0) * blue + 0.5);
-        *u = (long)(128 - (44.0 / 256.0) * red - (87.0 / 256.0) * green + (131.0 / 256.0) * blue + 0.5);        
-        *v = (long)(128 + (131.0 / 256.0) * red - (110.0 / 256.0) * green - (21.0 / 256.0) * blue + 0.5);
+        *y = (int)((77.0 / 256.0) * red + (150.0 / 256.0) * green + (29.0 / 256.0) * blue + 0.5);
+        *u = (int)(128 - (44.0 / 256.0) * red - (87.0 / 256.0) * green + (131.0 / 256.0) * blue + 0.5);        
+        *v = (int)(128 + (131.0 / 256.0) * red - (110.0 / 256.0) * green - (21.0 / 256.0) * blue + 0.5);
         */
 
         // Method from solving dequantizer equations
-        *y = (long)( .25695 * red + .50442 * green + .09773 * blue + 16.5);
-        *u = (long)(-.14821 * red - .29095 * green + .43917 * blue + 128.5);
-        *v = (long)( .43917 * red - .36788 * green - .07128 * blue + 128.5);
+        *y = (int)( .25695 * red + .50442 * green + .09773 * blue + 16.5);
+        *u = (int)(-.14821 * red - .29095 * green + .43917 * blue + 128.5);
+        *v = (int)( .43917 * red - .36788 * green - .07128 * blue + 128.5);
 
         // Clamp YUV
 
@@ -587,9 +587,9 @@ _txImgQuantizeYUV(FxU16 *dst, const FxU3
 {
         int k = w * h;
     int i, j;
-        unsigned long Y[2], U[2], V[2];
-        unsigned long avgU, avgV;
-        long tmpY, tmpU, tmpV;
+        unsigned int Y[2], U[2], V[2];
+        unsigned int avgU, avgV;
+        int tmpY, tmpU, tmpV;
     const FxU32 *localSrc = NULL;
 
     /* surface size must be a multiple of the 2x1 block size */
@@ -607,13 +607,13 @@ _txImgQuantizeYUV(FxU16 *dst, const FxU3
 
             src++;
 
-                        Y[j] = (unsigned long) tmpY;
-                        U[j] = (unsigned long) tmpU;
-                        V[j] = (unsigned long) tmpV;
+                        Y[j] = (unsigned int) tmpY;
+                        U[j] = (unsigned int) tmpU;
+                        V[j] = (unsigned int) tmpV;
                 }
 
-                avgU = (unsigned long) ((U[0] + U[1] + 1) / 2.0);  // add 1 to round
-                avgV = (unsigned long) ((V[0] + V[1] + 1) / 2.0);  // add 1 to round
+                avgU = (unsigned int) ((U[0] + U[1] + 1) / 2.0);  // add 1 to round
+                avgV = (unsigned int) ((V[0] + V[1] + 1) / 2.0);  // add 1 to round
 
                 if ( format == GR_TEXFMT_YUYV_422 )
                 {
@@ -647,7 +647,7 @@ void 
 _txImgQuantizeAYUV(FxU32 *dst, FxU32 *src, int w, int h)
 {
     int i, k;
-        long y, u, v;
+        int y, u, v;
 
         k = w * h;
 
@@ -1114,7 +1114,7 @@ txImgQuantize(char *dst, char *src, 
                int w, int h, 
                FxU32 format, FxU32 dither)
 {
-    int (*quantizer)(unsigned long argb, int x, int y, int w);
+    int (*quantizer)(unsigned int argb, int x, int y, int w);
     int         x, y;
 
     dither &= TX_DITHER_MASK;
@@ -1220,7 +1220,7 @@ txImgQuantize(char *dst, char *src, 
     case GR_TEXFMT_ALPHA_INTENSITY_44:
       for (y=0; y<h; y++) {
         for (x=0; x<w; x++) {
-          *dst++ = (*quantizer)(*(unsigned long *)src, x, y, w);
+          *dst++ = (*quantizer)(*(unsigned int *)src, x, y, w);
           src += 4;
         }
       }
@@ -1240,7 +1240,7 @@ txImgQuantize(char *dst, char *src, 
         
         for (y=0; y<h; y++) {
           for (x=0; x<w; x++) {
-            *dst16++ = (*quantizer)(*(unsigned long *)src, x, y, w);
+            *dst16++ = (*quantizer)(*(unsigned int *)src, x, y, w);
             src += 4;
           }
         }
Index: b/swlibs/texus2/lib/rgt.c
===================================================================
--- a/swlibs/texus2/lib/rgt.c
+++ b/swlibs/texus2/lib/rgt.c
@@ -49,7 +49,7 @@ typedef struct _rgtHeader{
 
 
 
-static void swapShorts(unsigned short *array, long length)
+static void swapShorts(unsigned short *array, int length)
 {
     unsigned short s;
     while (length--) {
@@ -58,7 +58,7 @@ static void swapShorts(unsigned short *a
     }
 }
 
-static void swapLongs(unsigned int *array, long length)
+static void swapLongs(unsigned int *array, int length)
 {
     unsigned int s;
     while (length--) {
@@ -69,7 +69,7 @@ static void swapLongs(unsigned int *arra
 }
 
 // just swap RGB into BGR (leave MSB undefined)
-static void swapRGB(unsigned int *array, long length)
+static void swapRGB(unsigned int *array, int length)
 {
     unsigned int s;
     while (length--) {
@@ -161,7 +161,7 @@ _txReadRGTData( FILE *stream, TxMip *inf
 
 #if 1
         if (swap) {
-            swapRGB((unsigned int *)data32, (long)info->width);
+            swapRGB((unsigned int *)data32, (int)info->width);
         }
 #endif
 
Index: b/swlibs/texus2/lib/texus.h
===================================================================
--- a/swlibs/texus2/lib/texus.h
+++ b/swlibs/texus2/lib/texus.h
@@ -36,8 +36,14 @@ extern "C" { 
 typedef unsigned char   FxU8;
 typedef unsigned short  FxU16;
 typedef short           FxI16;
+#if defined(__alpha__) || defined(__LP64__)
+typedef unsigned int    FxU32;
+typedef int             FxI32;
+#else
 typedef unsigned long   FxU32;
 typedef long            FxI32;
+#endif
+typedef unsigned long   AnyPtr;
 typedef int             FxBool;
 
 /*
Index: b/swlibs/texus2/lib/texusint.h
===================================================================
--- a/swlibs/texus2/lib/texusint.h
+++ b/swlibs/texus2/lib/texusint.h
@@ -73,7 +73,7 @@ int     txGCD(int a, int b);
 int             txAspectRatio(int w, int h);
 void    txPanic(char *);
 void    txError(char *);
-void    txYABtoPal256(long *palette, const long* yabTable);
+void    txYABtoPal256(FxU32 *palette, const FxU32* yabTable);
 void    txRectCopy(FxU8 *dst, int dstStride, const FxU8 *src, int srcStride,
                         int width, int height);
 FxBool  txMipAlloc(TxMip *txMip);
@@ -96,7 +96,7 @@ extern  int *explode3;
 
 void    txDiffuseIndex(TxMip *pxMip, TxMip *txMip, int pixsize, 
                 const FxU32 *palette, int       ncolors);
-int             txNearestColor(long ir, long ig, long ib, const FxU32 *pal, int npal);
+int             txNearestColor(int ir, int ig, int ib, const FxU32 *pal, int npal);
 
 FxBool _txReadTGAHeader( FILE *stream, FxU32 cookie, TxMip *info);
 FxBool _txReadTGAData( FILE *stream, TxMip *info);
Index: b/swlibs/texus2/lib/util.c
===================================================================
--- a/swlibs/texus2/lib/util.c
+++ b/swlibs/texus2/lib/util.c
@@ -156,14 +156,14 @@ txGCD(int a, int b)
 }
 
 void
-txYABtoPal256(long *palette, const long* yabTable)
+txYABtoPal256(FxU32 *palette, const FxU32* yabTable)
 {
         // Convert YAB table to a 256 color palette 
         // Assume yabTable[] has first 16Y's, 12 A's, 12 B's
 
-        const   long    *Y = yabTable;
-        const   long    *A = yabTable + 16;
-        const   long    *B = yabTable + 16 + 12;
+        const   FxU32    *Y = yabTable;
+        const   FxU32    *A = yabTable + 16;
+        const   FxU32    *B = yabTable + 16 + 12;
         int             i;
 
         for (i=0; i<256; i++) {
@@ -288,7 +288,7 @@ int     _explode3[255+256] = {
 int  *explode3 = &_explode3[255];
 
 int
-txNearestColor(long ir, long ig, long ib, const FxU32 *pal, int ncolors)
+txNearestColor(int ir, int ig, int ib, const FxU32 *pal, int ncolors)
 {
         int             i, d; 
         int             mindist, minpos;                // closest distance to input
